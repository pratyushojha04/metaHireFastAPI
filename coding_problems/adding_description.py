import pandas as pd
import csv

# Dictionary of problem descriptions for all unique IDs
problem_descriptions = {
    1: "Given an array of integers and a target sum, find indices of two numbers that add up to the target. Assume exactly one solution exists, and each element can be used only once, solved efficiently using a hash map.",
    3: "Find the length of the longest substring in a string that contains no repeating characters. Use a sliding window with a hash set to track unique characters, handling edge cases like empty strings.",
    4: "Given two sorted arrays, find the median of their merged array. Use binary search to partition the arrays efficiently, handling cases where arrays have different lengths or are empty, targeting O(log(min(m,n))) time.",
    5: "Find the longest palindromic substring in a given string. Expand around each character or gap as a potential palindrome center, ensuring O(n^2) time complexity and handling single-character or empty strings.",
    6: "Convert a string into a zigzag pattern with a given number of rows and read it row by row. Simulate the zigzag by tracking row indices, handling edge cases like one row or short strings in O(n) time.",
    8: "Convert a string to a 32-bit signed integer, handling leading whitespace, signs, and overflow. Parse digits until a non-digit is encountered, returning the clamped value if it exceeds the 32-bit integer range.",
    11: "Given an array of heights, find the maximum area of water that can be trapped between two lines. Use two pointers to scan from both ends, updating the maximum area in O(n) time while handling varying heights.",
    15: "Find all unique triplets in an array that sum to zero. Sort the array and use two pointers to find triplets in O(n^2) time, avoiding duplicates by skipping repeated values.",
    17: "Given a string of digits, return all possible letter combinations mapped to a phone keypad. Use backtracking to generate combinations, handling empty inputs or single digits in O(4^n) time.",
    19: "Remove the nth node from the end of a singly linked list in one pass. Use two pointers with a gap of n nodes to locate and remove the target node, handling edge cases like removing the head.",
    20: "Determine if a string of parentheses is valid by ensuring matching pairs. Use a stack to track opening brackets, checking for correct closure in O(n) time, handling empty or mismatched strings.",
    21: "Merge two sorted linked lists into a single sorted list. Compare node values iteratively or recursively, merging in O(n+m) time, where n and m are the list lengths, handling empty lists.",
    22: "Generate all valid combinations of n pairs of parentheses. Use backtracking to build strings with balanced parentheses, ensuring O(2^n) time for Catalan number outputs.",
    23: "Merge k sorted linked lists into one sorted list. Use a min-heap to efficiently select the smallest node from k lists, achieving O(n log k) time, where n is the total number of nodes.",
    24: "Swap adjacent nodes in a linked list in pairs. Adjust pointers to swap nodes in-place in O(n) time, handling odd-length lists or single nodes.",
    26: "Remove duplicates from a sorted array in-place, returning the length of the unique portion. Use two pointers to track unique elements, achieving O(n) time and O(1) space.",
    28: "Find the first occurrence of a substring (needle) in a string (haystack). Implement string matching (e.g., KMP) or use built-in methods for O(n+m) time, handling cases where needle is empty or not found.",
    29: "Divide two integers without using multiplication, division, or modulo operators, handling 32-bit overflow. Use bit manipulation or repeated subtraction for O(log n) time, ensuring correct sign and overflow clamping.",
    31: "Rearrange an array to form the next lexicographically greater permutation. Find the first decreasing element, swap with the smallest larger element, and reverse the suffix in O(n) time.",
    33: "Search for a target in a rotated sorted array with no duplicates. Use modified binary search to find the pivot and target in O(log n) time, handling cases where the array is not rotated.",
    34: "Find the first and last positions of a target in a sorted array. Use two binary searches to locate the boundaries in O(log n) time, returning [-1, -1] if the target is not found.",
    35: "Find the index where a target should be inserted in a sorted array to maintain order. Use binary search for O(log n) time, returning the correct index for existing or non-existing targets.",
    36: "Determine if a 9x9 Sudoku board is valid by checking rows, columns, and 3x3 sub-boxes for duplicates. Use hash sets for O(1) lookups, ensuring only digits 1-9 are valid and handling empty cells ('.').",
    38: "Generate the nth term of the count-and-say sequence, where each term describes the count of consecutive digits in the previous term. Iterate through the sequence, building each term in O(n * m) time, where m is the term length.",
    39: "Find all unique combinations of numbers in an array that sum to a target, with unlimited use of each number. Use backtracking to explore combinations in O(2^n) time, ensuring candidates are positive.",
    40: "Find all unique combinations of numbers in an array that sum to a target, with each number used at most once. Use backtracking with sorting to avoid duplicates in O(2^n) time, handling empty or invalid cases.",
    41: "Find the smallest missing positive integer in an unsorted array. Use the array as a hash table by marking indices in O(n) time and O(1) space, ignoring non-positive numbers.",
    42: "Calculate the total water trapped between bars of given heights. Use two pointers or a stack to compute trapped water in O(n) time, ensuring water is bounded by taller bars.",
    43: "Multiply two large numbers represented as strings, returning the product as a string. Simulate digit-by-digit multiplication in O(n*m) time, handling edge cases like zero or single digits.",
    44: "Determine if a string matches a pattern with wildcards ('*' for any sequence, '?' for any character). Use dynamic programming for O(n*m) time, handling complex patterns and edge cases.",
    45: "Find the minimum number of jumps to reach the end of an array, where each element is the maximum jump length. Use a greedy approach to track the farthest reachable index in O(n) time.",
    46: "Generate all possible permutations of a distinct integer array. Use backtracking to swap elements and generate permutations in O(n!) time, handling single-element or empty arrays.",
    48: "Rotate a square matrix 90 degrees clockwise in-place. Use transpose (swap across diagonal) followed by row reversal in O(n^2) time and O(1) space, handling 1x1 or larger matrices.",
    49: "Group an array of strings into anagrams. Use a hash map with sorted characters or character frequency as keys in O(n*k*log k) time, where k is the maximum string length, handling empty or single strings.",
    53: "Find the contiguous subarray with the largest sum and return its sum. Use Kadane’s algorithm for O(n) time, handling negative numbers and single-element arrays.",
    54: "Traverse a matrix in spiral order, returning elements in a single array. Use four pointers to track boundaries, moving inward in O(n*m) time, handling single-row or single-column matrices.",
    55: "Determine if the end of an array can be reached by jumping, where each element is the maximum jump length. Use a greedy approach to track the maximum reachable index in O(n) time.",
    56: "Merge overlapping intervals in a list of intervals. Sort by start time and merge in O(n log n) time, handling cases with no overlaps or single intervals.",
    57: "Insert a new interval into a list of non-overlapping intervals and merge overlaps. Insert and merge in O(n) time after sorting, handling cases where the new interval is disjoint.",
    59: "Generate an n x n matrix filled with numbers 1 to n^2 in spiral order. Use four pointers to fill the matrix layer by layer in O(n^2) time, handling edge cases like n=0 or n=1.",
    60: "Find the kth lexicographical permutation of numbers 1 to n. Use factorial-based indexing to construct the permutation in O(n) time, handling cases where k exceeds valid permutations.",
    61: "Rotate a linked list to the right by k places. Find the new head by adjusting pointers in O(n) time, handling cases where k exceeds the list length or the list is empty.",
    62: "Count unique paths from the top-left to the bottom-right of an m x n grid, moving only right or down. Use dynamic programming for O(m*n) time, handling small grids like 1x1.",
    63: "Count unique paths in an m x n grid with obstacles that block certain cells. Use dynamic programming to compute paths in O(m*n) time, handling cases with obstacles at the start or end.",
    64: "Find the minimum path sum from top-left to bottom-right in an m x n grid, moving only right or down. Use dynamic programming for O(m*n) time and O(min(m,n)) space, handling single-cell grids.",
    66: "Increment a non-negative number represented as an array of digits by one. Handle carry-over from right to left in O(n) time, accommodating cases like [9,9] or single-digit arrays.",
    67: "Add two binary strings and return the result as a binary string. Simulate binary addition digit by digit with carry in O(n) time, handling leading zeros or unequal lengths.",
    69: "Compute the integer square root of a non-negative number without using built-in square root functions. Use binary search for O(log n) time, handling edge cases like x=0 or x=1.",
    70: "Find the number of ways to climb n stairs, taking 1 or 2 steps at a time. Use dynamic programming for O(n) time and O(1) space, handling cases like n=0 or n=1.",
    71: "Simplify a Unix-style file path by resolving '.' and '..' components. Use a stack to process path segments in O(n) time, handling edge cases like empty paths or multiple slashes.",
    72: "Find the minimum number of operations (insert, delete, replace) to transform one word into another. Use a dynamic programming table for O(m*n) time, where m and n are word lengths.",
    73: "Set entire rows and columns to zero in a matrix if any element is zero, in-place. Use the first row and column as markers to track zeros in O(m*n) time and O(1) space, handling edge cases.",
    74: "Search for a target in an m x n matrix where each row and column is sorted. Start from the top-right corner for O(m+n) time, leveraging sorted properties to eliminate rows or columns.",
    75: "Sort an array of 0s, 1s, and 2s in-place (Dutch National Flag problem). Use three pointers to partition the array in O(n) time and O(1) space, handling single-element arrays.",
    76: "Find the shortest substring of a string containing all characters of a given string t. Use a sliding window with a hash map for O(n) time, handling cases where no valid substring exists.",
    77: "Generate all combinations of k numbers chosen from 1 to n. Use backtracking to build combinations in O(n choose k) time, handling cases like k=0 or k=n.",
    78: "Generate all possible subsets of a distinct integer array. Use backtracking or bit manipulation for O(2^n) time, including the empty subset and handling single-element arrays.",
    79: "Determine if a word exists in a 2D board by forming it from adjacent letters. Use DFS with backtracking for O(n*m*4^w) time, where w is the word length, marking visited cells to avoid reuse.",
    80: "Remove duplicates from a sorted array in-place, allowing at most two duplicates, and return the new length. Use two pointers for O(n) time, handling cases with no duplicates or single elements.",
    81: "Search for a target in a rotated sorted array that may contain duplicates. Use modified binary search for O(n) worst-case time due to duplicates, handling edge cases like single elements.",
    82: "Remove all nodes from a sorted linked list that have duplicates, keeping only unique values. Use pointers to skip duplicate nodes in O(n) time, handling cases with all duplicates.",
    83: "Remove duplicates from a sorted linked list, keeping one instance of each value. Traverse the list with a pointer, skipping duplicates in O(n) time, handling single-node or empty lists.",
    84: "Find the largest rectangle area in a histogram of bar heights. Use a stack to track increasing heights and compute areas in O(n) time, handling single-bar or uniform-height cases.",
    85: "Find the area of the largest rectangle of all 1s in a binary matrix. Treat each row as a histogram and use a stack-based approach for O(m*n) time, handling empty or single-cell matrices.",
    88: "Merge two sorted arrays into the first array in-place, given extra space at the end. Merge from the end to avoid overwriting in O(m+n) time, handling cases with empty arrays.",
    89: "Generate a Gray code sequence for a given n, where each number differs by one bit. Use bit manipulation or mirroring for O(2^n) time, ensuring valid sequences for n=0 or n=1.",
    90: "Generate all unique subsets of an array that may contain duplicates. Use backtracking with sorting to skip duplicates in O(2^n) time, including the empty subset.",
    91: "Count the number of ways to decode a string of digits into letters (1=A, 2=B, ..., 26=Z). Use dynamic programming for O(n) time, handling leading zeros and invalid sequences.",
    92: "Reverse a linked list between positions left and right (1-indexed). Locate the sublist, reverse it, and reconnect in O(n) time, handling cases where left equals right or the list is short.",
    94: "Return the inorder traversal of a binary tree (left, root, right). Use recursive or iterative (stack-based) traversal for O(n) time, handling empty or single-node trees.",
    95: "Generate all structurally unique binary search trees (BSTs) for numbers 1 to n. Use recursive construction for O(Catalan(n)) time, handling cases like n=0 or n=1.",
    96: "Count the number of unique binary search trees possible with n distinct nodes. Use dynamic programming or Catalan numbers for O(n^2) time, handling n=0 or small inputs.",
    97: "Determine if a string s3 is an interleaving of strings s1 and s2. Use dynamic programming for O(m*n) time, where m and n are string lengths, checking if s3 can be formed by merging s1 and s2.",
    98: "Validate if a binary tree is a binary search tree (BST) where left subtree values are less than the node and right subtree values are greater. Use DFS with range checks for O(n) time, handling duplicate values.",
    99: "Recover a binary search tree with two swapped nodes by restoring correct BST properties. Use inorder traversal to identify and swap the misplaced nodes in O(n) time, handling minimal trees.",
    100: "Determine if two binary trees are identical in structure and node values. Compare trees recursively or iteratively in O(n) time, where n is the number of nodes, handling empty or mismatched trees.",
    101: "Check if a binary tree is symmetric (i.e., its left and right subtrees are mirror images). Use recursive or iterative comparison of mirrored nodes in O(n) time, handling single-node or empty trees.",
    102: "Return the level-order traversal of a binary tree, grouping nodes by level. Use BFS with a queue for O(n) time, collecting nodes level by level, handling empty or single-node trees.",
    103: "Perform a zigzag level-order traversal of a binary tree, alternating left-to-right and right-to-left. Use BFS with a flag to reverse alternate levels in O(n) time, handling small or empty trees.",
    104: "Find the maximum depth of a binary tree (longest root-to-leaf path). Use DFS or BFS for O(n) time, returning 0 for empty trees and handling unbalanced trees.",
    105: "Construct a binary tree from its preorder and inorder traversals. Use preorder to identify the root and inorder to split subtrees, building the tree in O(n) time with a hash map for efficiency.",
    106: "Construct a binary tree from its inorder and postorder traversals. Use postorder to identify the root and inorder to split subtrees, constructing the tree in O(n) time with a hash map.",
    107: "Return the level-order traversal of a binary tree from bottom to top. Use BFS and reverse the result in O(n) time, handling empty trees or single-level trees.",
    108: "Convert a sorted array into a height-balanced binary search tree. Choose the middle element as the root for each subtree in O(n) time, ensuring balance for small or single-element arrays.",
    109: "Convert a sorted linked list into a height-balanced binary search tree. Find the middle node for each subtree in O(n log n) time, or optimize to O(n) with a fast-slow pointer approach.",
    110: "Determine if a binary tree is height-balanced, where the height difference between subtrees is at most 1. Use DFS to compute heights in O(n) time, checking balance for each node.",
    111: "Find the minimum depth of a binary tree (shortest root-to-leaf path). Use BFS for O(n) time to find the first leaf, handling unbalanced or empty trees.",
    112: "Check if a binary tree has a root-to-leaf path summing to a target value. Use DFS to explore paths in O(n) time, handling negative numbers and empty trees.",
    113: "Find all root-to-leaf paths in a binary tree where the sum equals a target value. Use DFS with backtracking to collect valid paths in O(n) time, handling cases with no valid paths.",
    114: "Flatten a binary tree into a linked list in-place using preorder traversal. Restructure the tree by setting left pointers to null and linking right pointers in O(n) time.",
    116: "Connect the next pointers of nodes at the same level in a perfect binary tree. Use BFS or constant space by leveraging next pointers in O(n) time, handling single-node or empty trees.",
    117: "Connect the next pointers of nodes at the same level in any binary tree. Use BFS or optimized constant space with next pointers in O(n) time, handling non-perfect trees.",
    118: "Generate the first n rows of Pascal’s triangle, where each number is the sum of the two numbers above it. Build each row iteratively in O(n^2) time, handling n=0 or n=1.",
    119: "Generate the kth row of Pascal’s triangle using only O(k) extra space. Compute the row iteratively in O(k) time, handling cases like k=0 or k=1.",
    120: "Find the minimum path sum from top to bottom in a triangle of numbers, moving to adjacent numbers in the next row. Use dynamic programming for O(n^2) time and O(n) space, where n is the number of rows.",
    121: "Find the maximum profit from buying and selling a stock once, given an array of daily prices. Track the minimum price and maximum profit in O(n) time, handling cases with no profit.",
    122: "Maximize profit by buying and selling a stock multiple times, given daily prices, without overlapping transactions. Sum all positive price differences in O(n) time, handling decreasing prices.",
    124: "Find the maximum path sum in a binary tree, where the path can include any node-to-node segment. Use DFS to track maximum sums through each node in O(n) time, handling negative values.",
    125: "Determine if a string is a palindrome, ignoring non-alphanumeric characters and case. Use two pointers to compare valid characters in O(n) time, handling empty or single-character strings.",
    126: "Find all shortest transformation sequences from a start word to an end word, changing one letter at a time via a word list. Use BFS to find shortest paths and backtracking for all sequences in O(n*26^l) time, where l is word length.",
    127: "Find the shortest transformation sequence length from a start word to an end word, changing one letter at a time via a word list. Use BFS for O(n*26^l) time, returning 0 if no sequence exists.",
    128: "Find the length of the longest consecutive sequence in an unsorted array of integers. Use a hash set for O(n) time lookup, checking sequence starts and lengths, handling duplicates.",
    129: "Sum all numbers formed by root-to-leaf paths in a binary tree, where each path represents a number. Use DFS to construct numbers in O(n) time, handling multi-digit nodes and single-node trees.",
    130: "Modify a board in-place by flipping surrounded 'O' regions to 'X', where surrounded means no connection to the border. Use DFS from border 'O's to mark connected regions in O(m*n) time, handling small boards.",
    133: "Clone a graph with nodes having neighbors and random pointers. Use DFS or BFS with a hash map to copy nodes and edges in O(n) time, where n is the number of nodes, handling cyclic graphs.",
    134: "Determine if a car can complete a circuit given gas and cost arrays, returning the starting station index. Check if total gas is sufficient and find the start point in O(n) time, handling single-station cases.",
    135: "Assign candies to children based on ratings, ensuring higher-rated children get more candies than neighbors. Use two passes (left-to-right and right-to-left) for O(n) time, minimizing total candies.",
    136: "Find the single number in an array where every other number appears twice. Use XOR operations for O(n) time and O(1) space, handling single-element arrays.",
    137: "Find the single number in an array where every other number appears three times. Use bit manipulation to track numbers appearing once in O(n) time, handling single-element cases.",
    138: "Copy a linked list with random pointers, preserving the structure. Interleave the original and copied nodes for O(n) time and O(1) space, then separate, handling lists with no random pointers.",
    139: "Determine if a string can be segmented into words from a dictionary. Use dynamic programming for O(n^2) time with a hash set for word lookup, handling empty strings or dictionaries.",
    140: "Find all possible word segmentations of a string using a dictionary. Use backtracking or dynamic programming with memoization for O(2^n) time, returning empty lists for invalid cases.",
    141: "Detect if a linked list has a cycle using Floyd’s cycle detection algorithm. Use two pointers (slow and fast) for O(n) time and O(1) space, returning false for empty or acyclic lists.",
    142: "Find the node where a cycle begins in a linked list using Floyd’s algorithm. Use two pointers to detect the cycle and locate the entrance in O(n) time, returning null for acyclic lists.",
    143: "Reorder a linked list by interleaving the first half with the reversed second half. Find the middle, reverse the second half, and merge in O(n) time, handling odd or even-length lists.",
    144: "Return the preorder traversal of a binary tree (root, left, right). Use recursive or iterative (stack-based) traversal for O(n) time, handling empty or single-node trees.",
    145: "Return the postorder traversal of a binary tree (left, right, root). Use recursive or iterative (stack-based) traversal for O(n) time, handling empty or single-node trees.",
    146: "Implement an LRU (Least Recently Used) cache with get and put operations in O(1) time. Use a hash map and doubly linked list to track and evict the least recently used items, handling capacity constraints.",
    147: "Sort a linked list using insertion sort. Insert each node into its correct position in a sorted sublist for O(n^2) time, handling duplicates or single-node lists.",
    148: "Sort a linked list in O(n log n) time using merge sort. Split the list, sort recursively, and merge sorted halves, handling empty or single-node lists.",
    149: "Find the maximum number of points that lie on the same line in a 2D plane. Calculate slopes between pairs of points using a hash map for O(n^2) time, handling duplicate points and vertical lines.",
    150: "Evaluate a Reverse Polish Notation (postfix) expression using a stack. Process operands and operators in O(n) time, handling valid expressions with integers and basic operators (+, -, *, /).",
    151: "Reverse the order of words in a string, removing extra spaces. Split the string, reverse the words, and join with single spaces in O(n) time, handling leading/trailing spaces or single words.",
    152: "Find the maximum product of a contiguous subarray in an array. Track maximum and minimum products due to negative numbers in O(n) time, handling zero or single-element arrays.",
    153: "Find the minimum element in a rotated sorted array with no duplicates. Use binary search for O(log n) time, leveraging the sorted structure to locate the pivot.",
    154: "Find the minimum element in a rotated sorted array that may contain duplicates. Use modified binary search for O(n) worst-case time due to duplicates, handling single-element arrays.",
    155: "Design a stack that supports push, pop, top, and getMin operations in O(1) time. Use two stacks to track values and minimums, handling empty stack scenarios.",
    160: "Find the intersection node of two linked lists, if it exists. Use two pointers to align lists by length in O(n+m) time and O(1) space, returning null if no intersection exists.",
    162: "Find any index of a peak element in an array where it is greater than its neighbors. Use binary search for O(log n) time, handling single-element or edge cases.",
    165: "Compare two version strings (e.g., '1.01' vs '1.001') and return -1, 0, or 1. Split versions into segments and compare numerically in O(n) time, handling unequal lengths or leading zeros.",
    166: "Convert a fraction to a decimal string, capturing repeating decimals in parentheses. Use long division with a hash map to detect repeating remainders in O(n) time, handling negative numbers.",
    167: "Find indices of two numbers in a sorted array that add up to a target. Use two pointers for O(n) time, leveraging the sorted order, assuming exactly one solution exists.",
    168: "Convert a positive integer to its corresponding Excel column title (base-26). Compute the title using division and modulo in O(log n) time, handling cases like 1=A, 26=Z, 27=AA.",
    169: "Find the majority element in an array that appears more than n/2 times. Use Boyer-Moore voting algorithm for O(n) time and O(1) space, assuming a majority exists.",
    171: "Convert an Excel column title (e.g., 'AB') to its corresponding column number (base-26). Compute the number by treating the title as a base-26 string in O(n) time, handling single or multi-character titles.",
    172: "Count the number of trailing zeros in n!. Calculate the number of factors of 5 in O(log n) time, as they limit the number of 10s formed with factors of 2.",
    173: "Implement an iterator for inorder traversal of a binary search tree. Use a stack to track nodes for O(1) average time per call and O(h) space, where h is the tree height.",
    174: "Calculate the minimum initial health needed to navigate a dungeon grid with positive/negative values to reach the bottom-right. Use dynamic programming for O(m*n) time, computing health backward from the goal.",
    179: "Form the largest possible number by concatenating an array of integers. Sort numbers by a custom comparator for O(n log n) time, handling cases with zeros or single numbers.",
    187: "Find all 10-length DNA sequences that appear more than once in a string. Use a hash set or rolling hash for O(n) time, returning sequences in any order, handling short or non-repeating strings.",
    189: "Rotate an array to the right by k steps in-place. Use reverse operations (reverse all, then first k, then rest) for O(n) time and O(1) space, handling k larger than array length.",
    190: "Reverse the bits of a 32-bit unsigned integer. Use bitwise operations to swap bits in O(1) time (32 iterations), handling edge cases like 0 or all 1s.",
    191: "Count the number of 1 bits in a 32-bit unsigned integer. Use bitwise operations for O(1) time (32 iterations), handling cases like 0 or maximum integer.",
    198: "Maximize loot by robbing non-adjacent houses in an array of money values. Use dynamic programming for O(n) time and O(1) space, choosing to rob or skip each house.",
    199: "Return the rightmost nodes at each level of a binary tree (right side view). Use BFS or DFS with level tracking for O(n) time, handling skewed or single-node trees.",
    200: "Count the number of islands (connected '1's) in a 2D binary grid. Use DFS or BFS to mark connected components in O(m*n) time, handling empty or single-cell grids.",
    201: "Find the bitwise AND of all numbers in a range [left, right]. Compute the common prefix of binary representations in O(log n) time, handling cases where left equals right.",
    202: "Determine if a number is happy by checking if the sum of squares of its digits eventually reaches 1. Use a hash set to detect cycles in O(log n) time, handling single-digit cases.",
    203: "Remove all nodes with a given value from a linked list. Traverse the list, adjusting pointers to skip matching nodes in O(n) time, handling cases where all nodes are removed.",
    204: "Count the number of prime numbers less than n. Use the Sieve of Eratosthenes for O(n log log n) time, handling small inputs like n=0 or n=1.",
    205: "Check if two strings are isomorphic, meaning characters map one-to-one between them. Use a hash map to track mappings in O(n) time, ensuring bijection and handling equal strings.",
    206: "Reverse a singly linked list. Adjust pointers iteratively or recursively in O(n) time and O(1) space, handling empty or single-node lists.",
    207: "Determine if a course schedule with prerequisites can be completed without cycles. Use DFS or BFS to detect cycles in the directed graph in O(V+E) time, where V is courses and E is prerequisites.",
    208: "Implement a trie with insert, search, and startsWith operations for strings. Use a trie node structure for O(m) time per operation, where m is the word length, handling empty or prefix queries.",
    209: "Find the shortest subarray with a sum at least equal to a target. Use a sliding window for O(n) time, tracking the minimum length and handling cases with no solution.",
    210: "Find a valid order to take courses with prerequisites, or return empty if impossible. Use topological sort with DFS or BFS for O(V+E) time, handling acyclic and cyclic graphs.",
    211: "Design a data structure to add words and search with wildcards ('.' for any character). Use a trie with DFS for O(m*26^w) time for search, where m is word length and w is wildcards.",
    212: "Find all words from a list that can be formed by adjacent letters in a 2D board. Use a trie with DFS for O(n*m*4^w) time, where w is the maximum word length, optimizing with prefix matching.",
    213: "Maximize loot in a circular array of houses, where first and last houses are adjacent. Use dynamic programming with two cases (excluding first or last house) for O(n) time, handling single houses.",
    215: "Find the kth largest element in an unsorted array. Use a min-heap or quickselect for O(n log k) or O(n) average time, handling duplicates and k=1 or k=n cases.",
    216: "Find all combinations of k numbers from 1 to 9 that sum to n. Use backtracking for O(9 choose k) time, ensuring numbers are used once and handling invalid cases.",
    217: "Check if an array contains any duplicate elements. Use a hash set for O(n) time, returning true if any number appears more than once, handling empty or single-element arrays.",
    219: "Check if an array has two identical elements within k indices of each other. Use a hash map to track indices in O(n) time, handling cases where k exceeds array length.",
    221: "Find the area of the largest square of 1s in a binary matrix. Use dynamic programming to track square sizes in O(m*n) time, handling single-cell or empty matrices.",
    222: "Count the number of nodes in a complete binary tree. Use binary search on tree height for O(log^2 n) time, leveraging complete tree properties, or DFS for O(n) time.",
    223: "Compute the total area of two rectangles minus their overlapping area. Calculate each rectangle’s area and subtract the intersection in O(1) time, handling non-overlapping or identical rectangles.",
    224: "Evaluate a string expression with addition, subtraction, and parentheses. Use a stack to handle signs and parentheses in O(n) time, parsing numbers and operators correctly.",
    225: "Implement a stack using one or two queues, supporting push, pop, top, and empty operations. Simulate stack behavior in O(n) time for push (with one queue) or O(1) for most operations with two queues.",
    226: "Invert a binary tree by swapping every node’s left and right children. Use recursive or iterative DFS for O(n) time, handling empty or single-child trees.",
    227: "Evaluate a string expression with addition, subtraction, multiplication, and division, respecting operator precedence. Use a stack or two-pass parsing for O(n) time, handling spaces and single numbers.",
    228: "Summarize consecutive ranges in a sorted integer array with no duplicates. Iterate through the array to group ranges in O(n) time, formatting as 'a->b' for ranges or 'a' for single numbers.",
    229: "Find all elements in an array that appear more than n/3 times. Use Boyer-Moore voting for O(n) time and O(1) space, handling cases with zero, one, or two majority elements.",
    230: "Find the kth smallest element in a binary search tree. Use inorder traversal with a stack for O(h+k) time, where h is tree height, handling small k or single-node trees.",
    231: "Determine if a number is a power of two. Check if only one bit is set using bitwise operations in O(1) time, handling zero and negative numbers.",
    232: "Implement a queue using two stacks, supporting push, pop, peek, and empty operations. Use one stack for enqueue and another for dequeue in O(1) amortized time for pop/peek.",
    234: "Check if a linked list is a palindrome. Find the middle, reverse the second half, and compare in O(n) time and O(1) space, handling odd or even-length lists.",
    235: "Find the lowest common ancestor of two nodes in a binary search tree. Use BST properties to traverse to the LCA in O(h) time, where h is tree height, handling cases where nodes are equal.",
    236: "Find the lowest common ancestor of two nodes in a binary tree. Use DFS to find paths to both nodes and identify the LCA in O(n) time, handling cases where one node is the LCA.",
    237: "Delete a given node in a linked list (not the tail) by copying the next node’s value and deleting it. Adjust pointers in O(1) time, assuming the node is valid and not the last.",
    238: "Compute an array where each element is the product of all other elements, without using division. Use left and right product passes for O(n) time and O(1) output space, handling zeros.",
    239: "Find the maximum element in each sliding window of size k in an array. Use a deque to track indices of potential maximums in O(n) time, handling single-element windows.",
    240: "Search for a target in an m x n matrix where each row and column is sorted. Start from the top-right corner for O(m+n) time, eliminating rows or columns based on comparisons.",
    241: "Compute all possible results of an expression by adding parentheses around operators. Use divide-and-conquer to split at operators for O(2^n) time, handling single numbers or simple expressions.",
    242: "Check if two strings are anagrams by having identical character frequencies. Use a hash map or sorting for O(n) or O(n log n) time, handling empty or single-character strings.",
    243: "Find the minimum distance between two words in an array of strings. Track indices of both words and compute the minimum difference in O(n) time, handling cases where words are adjacent.",
    244: "Design a data structure to find the shortest distance between two words in an array efficiently. Store word indices in a hash map for O(n) preprocessing and O(min(m,n)) query time, where m,n are word occurrences.",
    245: "Find the minimum distance between two words in an array, allowing the same word for both inputs. Handle the case where word1 equals word2 by tracking consecutive occurrences in O(n) time.",
    246: "Check if a number string is strobogrammatic, meaning it looks the same when rotated 180 degrees (e.g., 69, 88). Use two pointers to verify valid digit pairs (0, 1, 6, 8, 9) in O(n) time, handling single digits."
}

# Read the input CSV
try:
    df = pd.read_csv('google_interview_questions_combined.csv', quoting=csv.QUOTE_ALL)
    print(f"Successfully read google_interview_questions_combined.csv ({len(df)} rows)")
except Exception as e:
    print(f"Error reading google_interview_questions_combined.csv: {e}")
    exit(1)

# Insert problem_description column after question
df.insert(2, 'problem_description', df['id'].map(problem_descriptions))

# Check for missing descriptions
missing = df[df['problem_description'].isna()]
if not missing.empty:
    print(f"Warning: Missing descriptions for IDs: {missing['id'].tolist()}")

# Save to new CSV
output_file = 'google_interview_questions_with_descriptions.csv'
df.to_csv(output_file, index=False, quoting=csv.QUOTE_ALL)
print(f"Output CSV '{output_file}' created successfully with {len(df)} rows.")