id,question,problem_description,tc1,tc2,tc3,tc4,tc5,company,difficulty,category,hint
1,Two Sum,"Given an array of integers and a target sum, find indices of two numbers that add up to the target. Assume exactly one solution exists, and each element can be used only once, solved efficiently using a hash map.","nums=[2,7,11,15], target=9, output=[0,1]","nums=[3,2,4], target=6, output=[1,2]","nums=[3,3], target=6, output=[0,1]","nums=[1,2,3,4], target=7, output=[2,3]","nums=[0,4,3,0], target=0, output=[0,3]","Google, Amazon, Facebook, Microsoft, Apple",Easy,"Array, Hash Table",Use a hash map to store numbers and their indices.
2,Longest Substring Without Repeating Characters,"Find the length of the longest substring in a string that contains no repeating characters. Use a sliding window with a hash set to track unique characters, handling edge cases like empty strings.","s='abcabcbb', output=3","s='bbbbb', output=1","s='pwwkew', output=3","s='', output=0","s='dvdf', output=3","Google, Amazon, Facebook, Microsoft",Medium,"String, Sliding Window",Use a sliding window with a hash set to track unique characters.
3,Median of Two Sorted Arrays,"Given two sorted arrays, find the median of their merged array. Use binary search to partition the arrays efficiently, handling cases where arrays have different lengths or are empty, targeting O(log(min(m,n))) time.","nums1=[1,3], nums2=[2], output=2.0","nums1=[1,2], nums2=[3,4], output=2.5","nums1=[0,0], nums2=[0,0], output=0.0","nums1=[], nums2=[1], output=1.0","nums1=[2], nums2=[], output=2.0","Google, Amazon, Microsoft",Hard,"Array, Binary Search, Divide and Conquer",Use binary search to partition arrays.
4,Longest Palindromic Substring,"Find the longest palindromic substring in a given string. Expand around each character or gap as a potential palindrome center, ensuring O(n^2) time complexity and handling single-character or empty strings.","s='babad', output='bab'","s='cbbd', output='bb'","s='a', output='a'","s='racecar', output='racecar'","s='aaaa', output='aaaa'","Google, Amazon, Facebook",Medium,"String, Dynamic Programming",Expand around the center to find palindromes.
5,ZigZag Conversion,"Convert a string into a zigzag pattern with a given number of rows and read it row by row. Simulate the zigzag by tracking row indices, handling edge cases like one row or short strings in O(n) time.","s='PAYPALISHIRING', numRows=3, output='PAHNAPLSIIGYIR'","s='PAYPALISHIRING', numRows=4, output='PINALSIGYAHRPI'","s='A', numRows=1, output='A'","s='AB', numRows=2, output='AB'","s='ABC', numRows=3, output='ABC'","Google, Amazon",Medium,String,Simulate zigzag by tracking row indices.
6,String to Integer (atoi),"Convert a string to a 32-bit signed integer, handling leading whitespace, signs, and overflow. Parse digits until a non-digit is encountered, returning the clamped value if it exceeds the 32-bit integer range.","s='42', output=42","s='-42', output=-42","s='4193 with words', output=4193","s='words and 987', output=0","s='-91283472332', output=-2147483648","Google, Amazon, Microsoft",Medium,String,"Handle signs, whitespace, and overflow."
7,Container With Most Water,"Given an array of heights, find the maximum area of water that can be trapped between two lines. Use two pointers to scan from both ends, updating the maximum area in O(n) time while handling varying heights.","height=[1,8,6,2,5,4,8,3,7], output=49","height=[1,1], output=1","height=[4,3,2,1,4], output=16","height=[1,2,1], output=2","height=[2,3,4,5], output=6","Google, Amazon, Facebook",Medium,"Array, Two Pointers",Use two pointers to maximize area.
8,3Sum,"Find all unique triplets in an array that sum to zero. Sort the array and use two pointers to find triplets in O(n^2) time, avoiding duplicates by skipping repeated values.","nums=[-1,0,1,2,-1,-4], output=[[-1,-1,2],[-1,0,1]]","nums=[0,0,0], output=[[0,0,0]]","nums=[1,2,3,4], output=[]","nums=[-2,0,1,1], output=[[-2,0,2]]","nums=[-1,0,1], output=[[-1,0,1]]","Google, Amazon, Facebook",Medium,"Array, Two Pointers",Sort and use two pointers to find triplets.
9,Letter Combinations of a Phone Number,"Given a string of digits, return all possible letter combinations mapped to a phone keypad. Use backtracking to generate combinations, handling empty inputs or single digits in O(4^n) time.","digits='23', output=['ad','ae','af','bd','be','bf','cd','ce','cf']","digits='', output=[]","digits='2', output=['a','b','c']","digits='7', output=['p','q','r','s']","digits='89', output=['tw','tx','ty','tz','uw','ux','uy','uz','vw','vx','vy','vz']","Google, Amazon",Medium,Backtracking,Use backtracking to generate all combinations.
10,Remove Nth Node From End of List,"Remove the nth node from the end of a singly linked list in one pass. Use two pointers with a gap of n nodes to locate and remove the target node, handling edge cases like removing the head.","head=[1,2,3,4,5], n=2, output=[1,2,3,5]","head=[1], n=1, output=[]","head=[1,2], n=1, output=[1]","head=[1,2,3], n=3, output=[2,3]","head=[1,2,3,4], n=1, output=[1,2,3]","Google, Amazon, Facebook",Medium,"Linked List, Two Pointers",Use two pointers to find the nth node from the end.
11,Valid Parentheses,"Determine if a string of parentheses is valid by ensuring matching pairs. Use a stack to track opening brackets, checking for correct closure in O(n) time, handling empty or mismatched strings.","s='()', output=true","s='()[]{}', output=true","s='(]', output=false","s='([)]', output=false","s='{[]}', output=true","Google, Amazon, Facebook",Easy,"String, Stack",Use a stack to match opening and closing brackets.
12,Merge Two Sorted Lists,"Merge two sorted linked lists into a single sorted list. Compare node values iteratively or recursively, merging in O(n+m) time, where n and m are the list lengths, handling empty lists.","list1=[1,2,4], list2=[1,3,4], output=[1,1,2,3,4,4]","list1=[], list2=[0], output=[0]","list1=[1], list2=[], output=[1]","list1=[1,2], list2=[3], output=[1,2,3]","list1=[2], list2=[1], output=[1,2]","Google, Amazon",Easy,Linked List,Merge lists by comparing node values.
13,Generate Parentheses,"Generate all valid combinations of n pairs of parentheses. Use backtracking to build strings with balanced parentheses, ensuring O(2^n) time for Catalan number outputs.","n=3, output=['((()))','(()())','(())()','()(()','()()()']","n=1, output=['()']","n=2, output=['(())','()()']","n=4, output=(14 valid combinations)","n=0, output=[]","Google, Amazon",Medium,Backtracking,Use backtracking to generate valid parentheses.
14,Merge k Sorted Lists,"Merge k sorted linked lists into one sorted list. Use a min-heap to efficiently select the smallest node from k lists, achieving O(n log k) time, where n is the total number of nodes.","lists=[[1,4,5],[1,3,4],[2,6]], output=[1,1,2,3,4,4,5,6]","lists=[], output=[]","lists=[[]], output=[]","lists=[[1]], output=[1]","lists=[[1,2],[3,4]], output=[1,2,3,4]","Google, Amazon, Facebook, Microsoft",Hard,"Linked List, Divide and Conquer, Heap",Use a min-heap to merge lists efficiently.
15,Swap Nodes in Pairs,"Swap adjacent nodes in a linked list in pairs. Adjust pointers to swap nodes in-place in O(n) time, handling odd-length lists or single nodes.","head=[1,2,3,4], output=[2,1,4,3]","head=[1], output=[1]","head=[1,2], output=[2,1]","head=[1,2,3], output=[2,1,3]","head=[1,2,3,4,5], output=[2,1,4,3,5]","Google, Amazon",Medium,Linked List,Swap adjacent nodes by adjusting pointers.
16,Remove Duplicates from Sorted Array,"Remove duplicates from a sorted array in-place, returning the length of the unique portion. Use two pointers to track unique elements, achieving O(n) time and O(1) space.","nums=[1,1,2], output=2","nums=[0,0,1,1,1,2,2,3,3,4], output=5","nums=[1], output=1","nums=[1,1,1], output=1","nums=[1,2,3], output=3","Google, Amazon, Microsoft",Easy,"Array, Two Pointers",Use two pointers to keep unique elements.
17,Find the Index of the First Occurrence in a String,"Find the first occurrence of a substring (needle) in a string (haystack). Implement string matching (e.g., KMP) or use built-in methods for O(n+m) time, handling cases where needle is empty or not found.","haystack='sadbutsad', needle='sad', output=0","haystack='leetcode', needle='leeto', output=-1","haystack='hello', needle='ll', output=2","haystack='aaaaa', needle='bba', output=-1","haystack='abc', needle='c', output=2","Google, Amazon",Easy,String,Use string matching or KMP algorithm.
18,Divide Two Integers,"Divide two integers without using multiplication, division, or modulo operators, handling 32-bit overflow. Use bit manipulation or repeated subtraction for O(log n) time, ensuring correct sign and overflow clamping.","dividend=10, divisor=3, output=3","dividend=7, divisor=-3, output=-2","dividend=0, divisor=1, output=0","dividend=1, divisor=1, output=1","dividend=-2147483648, divisor=-1, output=2147483647","Google, Amazon",Medium,"Math, Bit Manipulation",Use bit manipulation for division without using / or %.
19,Next Permutation,"Rearrange an array to form the next lexicographically greater permutation. Find the first decreasing element, swap with the smallest larger element, and reverse the suffix in O(n) time.","nums=[1,2,3], output=[1,3,2]","nums=[3,2,1], output=[1,2,3]","nums=[1,1,5], output=[1,5,1]","nums=[1], output=[1]","nums=[1,2], output=[2,1]","Google, Amazon",Medium,Array,Find the next lexicographically greater permutation.
20,Search in Rotated Sorted Array,"Search for a target in a rotated sorted array with no duplicates. Use modified binary search to find the pivot and target in O(log n) time, handling cases where the array is not rotated.","nums=[4,5,6,7,0,1,2], target=0, output=4","nums=[4,5,6,7,0,1,2], target=3, output=-1","nums=[1], target=0, output=-1","nums=[1,3], target=3, output=1","nums=[5,1,3], target=3, output=2","Google, Amazon, Facebook",Medium,"Array, Binary Search",Use modified binary search for rotated array.
21,Find First and Last Position of Element in Sorted Array,"Find the first and last positions of a target in a sorted array. Use two binary searches to locate the boundaries in O(log n) time, returning [-1, -1] if the target is not found.","nums=[5,7,7,8,8,10], target=8, output=[3,4]","nums=[5,7,7,8,8,10], target=6, output=[-1,-1]","nums=[], target=0, output=[-1,-1]","nums=[1], target=1, output=[0,0]","nums=[2,2], target=2, output=[0,1]","Google, Amazon, Microsoft",Medium,"Array, Binary Search",Use two binary searches for boundaries.
22,Search Insert Position,"Find the index where a target should be inserted in a sorted array to maintain order. Use binary search for O(log n) time, returning the correct index for existing or non-existing targets.","nums=[1,3,5,6], target=5, output=2","nums=[1,3,5,6], target=2, output=1","nums=[1,3,5,6], target=7, output=4","nums=[1,3,5,6], target=0, output=0","nums=[1], target=1, output=0","Google, Amazon",Easy,"Array, Binary Search",Use binary search to find insertion point.
23,Valid Sudoku,"Determine if a 9x9 Sudoku board is valid by checking rows, columns, and 3x3 sub-boxes for duplicates. Use hash sets for O(1) lookups, ensuring only digits 1-9 are valid and handling empty cells ('.').","board=[['5','3','.','.','7','.','.','.','.'],['6','.','.','1','9','5','.','.','.'],['.','9','8','.','.','.','.','6','.'],['8','.','.','.','6','.','.','.','3'],['4','.','.','8','.','3','.','.','1'],['7','.','.','.','2','.','.','.','6'],['.','6','.','.','.','.','2','8','.'],['.','.','.','4','1','9','.','.','5'],['.','.','.','.','8','.','.','7','9']], output=true","board=[['8','3','.','.','7','.','.','.','.'],['6','.','.','1','9','5','.','.','.'],['.','9','8','.','.','.','.','6','.'],['8','.','.','.','6','.','.','.','3'],['4','.','.','8','.','3','.','.','1'],['7','.','.','.','2','.','.','.','6'],['.','6','.','.','.','.','2','8','.'],['.','.','.','4','1','9','.','.','5'],['.','.','.','.','8','.','.','7','9']], output=false","board=[['1','.','.'],['.','2','.'],['.','.','3']], output=true","board=[['1','1','.'],['.','2','.'],['.','.','3']], output=false","board=[['.','.','.'],['.','.','.'],['.','.','.']], output=true","Google, Amazon",Medium,"Array, Hash Table","Check rows, columns, and 3x3 sub-boxes for duplicates."
24,Count and Say,"Generate the nth term of the count-and-say sequence, where each term describes the count of consecutive digits in the previous term. Iterate through the sequence, building each term in O(n * m) time, where m is the term length.","n=1, output='1'","n=2, output='11'","n=3, output='21'","n=4, output='1211'","n=5, output='111221'","Google, Amazon",Medium,String,Count consecutive digits to generate the next sequence.
25,Combination Sum,"Find all unique combinations of numbers in an array that sum to a target, with unlimited use of each number. Use backtracking to explore combinations in O(2^n) time, ensuring candidates are positive.","candidates=[2,3,6,7], target=7, output=[[2,2,3],[7]]","candidates=[2,3,5], target=8, output=[[2,2,2,2],[2,3,3],[3,5]]","candidates=[2], target=1, output=[]","candidates=[1], target=1, output=[[1]]","candidates=[1,2], target=4, output=[[1,1,1,1],[1,1,2],[2,2]]","Google, Amazon",Medium,Backtracking,Use backtracking to find all combinations summing to target.
26,Combination Sum II,"Find all unique combinations of numbers in an array that sum to a target, with each number used at most once. Use backtracking with sorting to avoid duplicates in O(2^n) time, handling empty or invalid cases.","candidates=[10,1,2,7,6,1,5], target=8, output=[[1,1,6],[1,2,5],[1,7],[2,6]]","candidates=[2,5,2,1,2], target=5, output=[[1,2,2],[5]]","candidates=[1], target=1, output=[[1]]","candidates=[1,2], target=4, output=[[2,2]]","candidates=[2], target=1, output=[]","Google, Amazon",Medium,Backtracking,Use backtracking with deduplication for unique combinations.
27,First Missing Positive,"Find the smallest missing positive integer in an unsorted array. Use the array as a hash table by marking indices in O(n) time and O(1) space, ignoring non-positive numbers.","nums=[1,2,0], output=3","nums=[3,4,-1,1], output=2","nums=[7,8,9,11,12], output=1","nums=[1], output=2","nums=[1,2,3], output=4","Google, Amazon, Microsoft",Hard,Array,Use array as a hash table by marking indices.
28,Trapping Rain Water,"Calculate the total water trapped between bars of given heights. Use two pointers or a stack to compute trapped water in O(n) time, ensuring water is bounded by taller bars.","height=[0,1,0,2,1,0,1,3,2,1,2,1], output=6","height=[4,2,0,3,2,5], output=9","height=[1], output=0","height=[1,2], output=0","height=[2,0,2], output=2","Google, Amazon",Hard,"Array, Two Pointers, Stack",Use two pointers or stack to compute trapped water.
29,Multiply Strings,"Multiply two large numbers represented as strings, returning the product as a string. Simulate digit-by-digit multiplication in O(n*m) time, handling edge cases like zero or single digits.","num1='2', num2='3', output='6'","num1='123', num2='456', output='56088'","num1='0', num2='0', output='0'","num1='9', num2='9', output='81'","num1='123', num2='0', output='0'","Google, Amazon",Medium,"String, Math",Simulate multiplication digit by digit.
30,Wildcard Matching,"Determine if a string matches a pattern with wildcards ('*' for any sequence, '?' for any character). Use dynamic programming for O(n*m) time, handling complex patterns and edge cases.","s='aa', p='a', output=false","s='aa', p='*', output=true","s='cb', p='?a', output=false","s='adceb', p='*a*b', output=true","s='acdcb', p='a*c?b', output=false","Google, Amazon",Hard,"Dynamic Programming, String",Use DP to match string with wildcard pattern.
31,Jump Game II,"Find the minimum number of jumps to reach the end of an array, where each element is the maximum jump length. Use a greedy approach to track the farthest reachable index in O(n) time.","nums=[2,3,1,1,4], output=2","nums=[2,3,0,1,4], output=2","nums=[1], output=0","nums=[1,2], output=1","nums=[2,1], output=1","Google, Amazon",Medium,"Array, Greedy",Use greedy approach to minimize jumps.
32,Permutations,"Generate all possible permutations of a distinct integer array. Use backtracking to swap elements and generate permutations in O(n!) time, handling single-element or empty arrays.","nums=[1,2,3], output=[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]","nums=[0,1], output=[[0,1],[1,0]]","nums=[1], output=[[1]]","nums=[1,2], output=[[1,2],[2,1]]","nums=[1,2,3,4], output=(24 permutations)","Google, Amazon, Facebook",Medium,Backtracking,Use backtracking to generate all permutations.
33,Rotate Image,"Rotate a square matrix 90 degrees clockwise in-place. Use transpose (swap across diagonal) followed by row reversal in O(n^2) time and O(1) space, handling 1x1 or larger matrices.","matrix=[[1,2,3],[4,5,6],[7,8,9]], output=[[7,4,1],[8,5,2],[9,6,3]]","matrix=[[1]], output=[[1]]","matrix=[[1,2],[3,4]], output=[[3,1],[4,2]]","matrix=[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], output=[[13,9,5,1],[14,10,6,2],[15,11,7,3],[16,12,8,4]]","matrix=[[1,2],[3,4]], output=[[3,1],[4,2]]","Google, Amazon",Medium,"Array, Matrix",Rotate matrix in-place using transpose and reverse.
34,Group Anagrams,"Group an array of strings into anagrams. Use a hash map with sorted characters or character frequency as keys in O(n*k*log k) time, where k is the maximum string length, handling empty or single strings.","strs=['eat','tea','tan','ate','nat','bat'], output=[['eat','tea','ate'],['tan','nat'],['bat']]","strs=[''], output=[['']]","strs=['a'], output=[['a']]","strs=['ab','ba'], output=[['ab','ba']]","strs=['abc','cba','bac'], output=[['abc','cba','bac']]","Google, Amazon",Medium,"String, Hash Table",Group strings by sorted characters or character frequency.
35,Maximum Subarray,"Find the contiguous subarray with the largest sum and return its sum. Use Kadane’s algorithm for O(n) time, handling negative numbers and single-element arrays.","nums=[-2,1,-3,4,-1,2,1,-5,4], output=6","nums=[1], output=1","nums=[-1], output=-1","nums=[-2,-1], output=-1","nums=[1,2,3], output=6","Google, Amazon, Facebook",Easy,"Array, Dynamic Programming",Use Kadane’s algorithm to find the maximum subarray sum.
36,Spiral Matrix,"Traverse a matrix in spiral order, returning elements in a single array. Use four pointers to track boundaries, moving inward in O(n*m) time, handling single-row or single-column matrices.","matrix=[[1,2,3],[4,5,6],[7,8,9]], output=[1,2,3,6,9,8,7,4,5]","matrix=[[1,2,3,4],[5,6,7,8],[9,10,11,12]], output=[1,2,3,4,8,12,11,10,9,5,6,7]","matrix=[[1]], output=[1]","matrix=[[1,2],[3,4]], output=[1,2,4,3]","matrix=[[1,2,3]], output=[1,2,3]","Google, Amazon, Microsoft",Medium,"Array, Matrix",Use four pointers to traverse the matrix in spiral order.
37,Jump Game,"Determine if the end of an array can be reached by jumping, where each element is the maximum jump length. Use a greedy approach to track the maximum reachable index in O(n) time.","nums=[2,3,1,1,4], output=true","nums=[3,2,1,0,4], output=false","nums=[1], output=true","nums=[0], output=true","nums=[2,0], output=true","Google, Amazon",Medium,"Array, Greedy",Track the maximum reachable index using a greedy approach.
38,Merge Intervals,"Merge overlapping intervals in a list of intervals. Sort by start time and merge in O(n log n) time, handling cases with no overlaps or single intervals.","intervals=[[1,3],[2,6],[8,10],[15,18]], output=[[1,6],[8,10],[15,18]]","intervals=[[1,4],[4,5]], output=[[1,5]]","intervals=[[1,4]], output=[[1,4]]","intervals=[[1,4],[0,4]], output=[[0,4]]","intervals=[[1,4],[2,3]], output=[[1,4]]","Google, Amazon, Facebook",Medium,"Array, Sorting",Sort intervals by start time and merge overlapping ones.
39,Insert Interval,"Insert a new interval into a list of non-overlapping intervals and merge overlaps. Insert and merge in O(n) time after sorting, handling cases where the new interval is disjoint.","intervals=[[1,3],[6,9]], newInterval=[2,5], output=[[1,5],[6,9]]","intervals=[[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval=[4,8], output=[[1,2],[3,10],[12,16]]","intervals=[], newInterval=[5,7], output=[[5,7]]","intervals=[[1,5]], newInterval=[2,3], output=[[1,5]]","intervals=[[1,5]], newInterval=[6,8], output=[[1,5],[6,8]]","Google, Amazon",Medium,"Array, Intervals",Insert and merge the new interval with existing ones.
40,Spiral Matrix II,"Generate an n x n matrix filled with numbers 1 to n^2 in spiral order. Use four pointers to fill the matrix layer by layer in O(n^2) time, handling edge cases like n=0 or n=1.","n=3, output=[[1,2,3],[8,9,4],[7,6,5]]","n=1, output=[[1]]","n=2, output=[[1,2],[4,3]]","n=4, output=[[1,2,3,4],[12,13,14,5],[11,16,15,6],[10,9,8,7]]","n=0, output=[]","Google, Amazon",Medium,"Array, Matrix",Fill the matrix in a spiral pattern using four pointers.
41,Permutation Sequence,"Find the kth lexicographical permutation of numbers 1 to n. Use factorial-based indexing to construct the permutation in O(n) time, handling cases where k exceeds valid permutations.","n=3, k=3, output='213'","n=4, k=9, output='2314'","n=1, k=1, output='1'","n=2, k=1, output='12'","n=2, k=2, output='21'","Google, Amazon",Hard,"Math, Backtracking",Use factorial-based indexing to find the k-th permutation.
42,Rotate List,"Rotate a linked list to the right by k places. Find the new head by adjusting pointers in O(n) time, handling cases where k exceeds the list length or the list is empty.","head=[1,2,3,4,5], k=2, output=[4,5,1,2,3]","head=[0,1,2], k=4, output=[2,0,1]","head=[1], k=0, output=[1]","head=[1,2], k=1, output=[2,1]","head=[1,2,3], k=3, output=[1,2,3]","Google, Amazon",Medium,Linked List,Rotate the list by finding the new head after k nodes.
43,Unique Paths,"Count unique paths from the top-left to the bottom-right of an m x n grid, moving only right or down. Use dynamic programming for O(m*n) time, handling small grids like 1x1.","m=3, n=7, output=28","m=3, n=2, output=3","m=1, n=1, output=1","m=2, n=2, output=2","m=3, n=3, output=6","Google, Amazon",Medium,Dynamic Programming,Use DP to count paths from top-left to bottom-right.
44,Unique Paths II,"Count unique paths in an m x n grid with obstacles that block certain cells. Use dynamic programming to compute paths in O(m*n) time, handling cases with obstacles at the start or end.","obstacleGrid=[[0,0,0],[0,1,0],[0,0,0]], output=2","obstacleGrid=[[0,1],[0,0]], output=1","obstacleGrid=[[0]], output=1","obstacleGrid=[[1]], output=0","obstacleGrid=[[0,0],[1,1],[0,0]], output=0","Google, Amazon",Medium,Dynamic Programming,Use DP with obstacles blocking paths.
45,Minimum Path Sum,"Find the minimum path sum from top-left to bottom-right in an m x n grid, moving only right or down. Use dynamic programming for O(m*n) time and O(min(m,n)) space, handling single-cell grids.","grid=[[1,3,1],[1,5,1],[4,2,1]], output=7","grid=[[1,2],[1,1]], output=3","grid=[[1]], output=1","grid=[[1,2,3]], output=6","grid=[[1],[2],[3]], output=6","Google, Amazon",Medium,Dynamic Programming,Use DP to find the minimum path sum.
46,Plus One,"Increment a non-negative number represented as an array of digits by one. Handle carry-over from right to left in O(n) time, accommodating cases like [9,9] or single-digit arrays.","digits=[1,2,3], output=[1,2,4]","digits=[4,3,2,1], output=[4,3,2,2]","digits=[0], output=[1]","digits=[9], output=[1,0]","digits=[9,9], output=[1,0,0]","Google, Amazon",Easy,"Array, Math",Handle carry-over from right to left.
47,Add Binary,"Add two binary strings and return the result as a binary string. Simulate binary addition digit by digit with carry in O(n) time, handling leading zeros or unequal lengths.","a='11', b='1', output='100'","a='1010', b='1011', output='10101'","a='0', b='0', output='0'","a='1', b='0', output='1'","a='1111', b='1111', output='11110'","Google, Amazon",Easy,"String, Bit Manipulation",Simulate binary addition digit by digit.
48,Sqrt(x),"Compute the integer square root of a non-negative number without using built-in square root functions. Use binary search for O(log n) time, handling edge cases like x=0 or x=1.","x=4, output=2","x=8, output=2","x=0, output=0","x=1, output=1","x=16, output=4","Google, Amazon",Easy,"Math, Binary Search",Use binary search to find the square root.
49,Climbing Stairs,"Find the number of ways to climb n stairs, taking 1 or 2 steps at a time. Use dynamic programming for O(n) time and O(1) space, handling cases like n=0 or n=1.","n=2, output=2","n=3, output=3","n=1, output=1","n=4, output=5","n=0, output=1","Google, Amazon",Easy,Dynamic Programming,Use DP to compute ways to climb stairs.
50,Simplify Path,"Simplify a Unix-style file path by resolving '.' and '..' components. Use a stack to process path segments in O(n) time, handling edge cases like empty paths or multiple slashes.","path='/home/', output='/home'","path='/../', output='/'","path='/home//foo/', output='/home/foo'","path='/a/./b/../../c/', output='/c'","path='/a//b////c/d//././/..', output='/a/b/c'","Google, Amazon",Medium,"String, Stack",Use a stack to process path components.
51,Edit Distance,"Find the minimum number of operations (insert, delete, replace) to transform one word into another. Use a dynamic programming table for O(m*n) time, where m and n are word lengths.","word1='horse', word2='ros', output=3","word1='intention', word2='execution', output=5","word1='', word2='a', output=1","word1='abc', word2='abc', output=0","word1='cat', word2='cut', output=1","Google, Amazon",Hard,Dynamic Programming,Use a DP table for minimum operations.
52,Set Matrix Zeroes,"Set entire rows and columns to zero in a matrix if any element is zero, in-place. Use the first row and column as markers to track zeros in O(m*n) time and O(1) space, handling edge cases.","matrix=[[1,1,1],[1,0,1],[1,1,1]], output=[[1,0,1],[0,0,0],[1,0,1]]","matrix=[[0,1,2,0],[3,4,5,2],[1,3,1,5]], output=[[0,0,0,0],[0,4,5,0],[0,3,1,0]]","matrix=[[1]], output=[[1]]","matrix=[[0]], output=[[0]]","matrix=[[1,0],[0,1]], output=[[0,0],[0,0]]","Google, Amazon",Medium,"Array, Matrix",Use first row and column as markers for zeroes.
53,Search a 2D Matrix,"Search for a target in an m x n matrix where each row and column is sorted. Start from the top-right corner for O(m+n) time, leveraging sorted properties to eliminate rows or columns.","matrix=[[1,3,5,7],[10,11,16,20],[23,30,34,50]], target=3, output=true","matrix=[[1,3,5,7],[10,11,16,20],[23,30,34,50]], target=13, output=false","matrix=[[1]], target=1, output=true","matrix=[[1,2]], target=2, output=true","matrix=[[1],[3]], target=3, output=true","Google, Amazon, Microsoft",Medium,"Array, Binary Search",Treat matrix as a sorted array for binary search.
54,Sort Colors,"Sort an array of 0s, 1s, and 2s in-place (Dutch National Flag problem). Use three pointers to partition the array in O(n) time and O(1) space, handling single-element arrays.","nums=[2,0,2,1,1,0], output=[0,0,1,1,2,2]","nums=[2,0,1], output=[0,1,2]","nums=[0], output=[0]","nums=[1], output=[1]","nums=[2,2,0,0,1,1], output=[0,0,1,1,2,2]","Google, Amazon, Facebook",Medium,"Array, Two Pointers, Sorting",Use three pointers to partition colors.
55,Minimum Window Substring,"Find the shortest substring of a string containing all characters of a given string t. Use a sliding window with a hash map for O(n) time, handling cases where no valid substring exists.","s='ADOBECODEBANC', t='ABC', output='BANC'","s='a', t='a', output='a'","s='a', t='aa', output=''","s='ab', t='a', output='a'","s='ADOBEC', t='ABC', output='BEC'","Google, Amazon, Facebook",Hard,"String, Sliding Window",Use a sliding window to find the smallest substring containing all characters.
56,Combinations,"Generate all combinations of k numbers chosen from 1 to n. Use backtracking to build combinations in O(n choose k) time, handling cases like k=0 or k=n.","n=4, k=2, output=[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]","n=1, k=1, output=[[1]]","n=2, k=1, output=[[1],[2]]","n=2, k=2, output=[[1,2]]","n=3, k=2, output=[[1,2],[1,3],[2,3]]","Google, Amazon",Medium,Backtracking,Use backtracking to generate all combinations.
57,Subsets,"Generate all possible subsets of a distinct integer array. Use backtracking or bit manipulation for O(2^n) time, including the empty subset and handling single-element arrays.","nums=[1,2,3], output=[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]","nums=[0], output=[[],[0]]","nums=[1,2], output=[[],[1],[2],[1,2]]","nums=[1], output=[[],[1]]","nums=[2,3], output=[[],[2],[3],[2,3]]","Google, Amazon, Facebook",Medium,"Backtracking, Bit Manipulation",Use backtracking or bit manipulation for all subsets.
58,Word Search,"Determine if a word exists in a 2D board by forming it from adjacent letters. Use DFS with backtracking for O(n*m*4^w) time, where w is the word length, marking visited cells to avoid reuse.","board=[['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word='ABCCED', output=true","board=[['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word='SEE', output=true","board=[['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word='ABCB', output=false","board=[['A']], word='A', output=true","board=[['A','B']], word='AB', output=true","Google, Amazon, Microsoft",Medium,"Backtracking, Matrix",Use DFS with backtracking to find the word.
59,Remove Duplicates from Sorted Array II,"Remove duplicates from a sorted array in-place, allowing at most two duplicates, and return the new length. Use two pointers for O(n) time, handling cases with no duplicates or single elements.","nums=[1,1,1,2,2,3], output=5","nums=[0,0,1,1,1,1,2,3,3], output=7","nums=[1,1], output=2","nums=[1], output=1","nums=[1,2,2], output=3","Google, Amazon",Medium,"Array, Two Pointers",Allow at most two duplicates using two pointers.
60,Search in Rotated Sorted Array II,"Search for a target in a rotated sorted array that may contain duplicates. Use modified binary search for O(n) worst-case time due to duplicates, handling edge cases like single elements.","nums=[2,5,6,0,0,1,2], target=0, output=true","nums=[2,5,6,0,0,1,2], target=3, output=false","nums=[1], target=1, output=true","nums=[1,1], target=1, output=true","nums=[1,3,1,1,1], target=3, output=true","Google, Amazon",Medium,"Array, Binary Search",Handle duplicates with modified binary search.
61,Remove Duplicates from Sorted List II,"Remove all nodes from a sorted linked list that have duplicates, keeping only unique values. Use pointers to skip duplicate nodes in O(n) time, handling cases with all duplicates.","head=[1,2,3,3,4,4,5], output=[1,2,5]","head=[1,1,1,2,3], output=[2,3]","head=[1,1], output=[]","head=[1,2,2], output=[1]","head=[1], output=[1]","Google, Amazon",Medium,Linked List,Remove all nodes with duplicates using pointers.
62,Remove Duplicates from Sorted List,"Remove duplicates from a sorted linked list, keeping one instance of each value. Traverse the list with a pointer, skipping duplicates in O(n) time, handling single-node or empty lists.","head=[1,1,2], output=[1,2]","head=[1,1,2,3,3], output=[1,2,3]","head=[1], output=[1]","head=[1,1,1], output=[1]","head=[1,2], output=[1,2]","Google, Amazon",Easy,Linked List,Skip duplicates in a sorted list using a pointer.
63,Largest Rectangle in Histogram,"Find the largest rectangle area in a histogram of bar heights. Use a stack to track increasing heights and compute areas in O(n) time, handling single-bar or uniform-height cases.","heights=[2,1,5,6,2,3], output=10","heights=[2,4], output=4","heights=[1], output=1","heights=[2,2], output=4","heights=[1,2,3], output=4","Google, Amazon",Hard,"Array, Stack",Use a stack to compute areas of rectangles.
64,Maximal Rectangle,"Find the area of the largest rectangle of all 1s in a binary matrix. Treat each row as a histogram and use a stack-based approach for O(m*n) time, handling empty or single-cell matrices.","matrix=[['1','0','1','0','0'],['1','0','1','1','1'],['1','1','1','1','1'],['1','0','0','1','0']], output=6","matrix=[['0']], output=0","matrix=[['1']], output=1","matrix=[['1','0'],['0','1']], output=1","matrix=[['1','1'],['1','1']], output=4","Google, Amazon",Hard,"Dynamic Programming, Stack",Convert to histogram problem for each row.
65,Merge Sorted Array,"Merge two sorted arrays into the first array in-place, given extra space at the end. Merge from the end to avoid overwriting in O(m+n) time, handling cases with empty arrays.","nums1=[1,2,3,0,0,0], m=3, nums2=[2,5,6], n=3, output=[1,2,2,3,5,6]","nums1=[1], m=1, nums2=[], n=0, output=[1]","nums1=[0], m=0, nums2=[1], n=1, output=[1]","nums1=[2,0], m=1, nums2=[1], n=1, output=[1,2]","nums1=[1,2,0,0], m=2, nums2=[3,4], n=2, output=[1,2,3,4]","Google, Amazon",Easy,"Array, Two Pointers",Merge from the end to avoid overwriting.
66,Gray Code,"Generate a Gray code sequence for a given n, where each number differs by one bit. Use bit manipulation or mirroring for O(2^n) time, ensuring valid sequences for n=0 or n=1.","n=2, output=[0,1,3,2]","n=1, output=[0,1]","n=0, output=[0]","n=3, output=[0,1,3,2,6,7,5,4]","n=4, output=(16 numbers in Gray code sequence)","Google, Amazon",Medium,"Backtracking, Bit Manipulation",Generate sequence using bit manipulation or mirroring.
67,Subsets II,"Generate all unique subsets of an array that may contain duplicates. Use backtracking with sorting to skip duplicates in O(2^n) time, including the empty subset.","nums=[1,2,2], output=[[],[1],[1,2],[1,2,2],[2],[2,2]]","nums=[0], output=[[],[0]]","nums=[1,1], output=[[],[1],[1,1]]","nums=[1], output=[[],[1]]","nums=[2,2,2], output=[[],[2],[2,2],[2,2,2]]","Google, Amazon",Medium,Backtracking,Use backtracking with deduplication for subsets.
68,Decode Ways,"Count the number of ways to decode a string of digits into letters (1=A, 2=B, ..., 26=Z). Use dynamic programming for O(n) time, handling leading zeros and invalid sequences.","s='12', output=2","s='226', output=3","s='06', output=0","s='1', output=1","s='111', output=3","Google, Amazon",Medium,Dynamic Programming,Use DP to count valid decodings.
69,Reverse Linked List II,"Reverse a linked list between positions left and right (1-indexed). Locate the sublist, reverse it, and reconnect in O(n) time, handling cases where left equals right or the list is short.","head=[1,2,3,4,5], left=2, right=4, output=[1,4,3,2,5]","head=[5], left=1, right=1, output=[5]","head=[1,2], left=1, right=2, output=[2,1]","head=[1,2,3], left=1, right=3, output=[3,2,1]","head=[1,2,3,4], left=2, right=3, output=[1,3,2,4]","Google, Amazon",Medium,Linked List,Reverse the sublist between left and right positions.
70,Binary Tree Inorder Traversal,"Return the inorder traversal of a binary tree (left, root, right). Use recursive or iterative (stack-based) traversal for O(n) time, handling empty or single-node trees.","root=[1,null,2,3], output=[1,3,2]","root=[], output=[]","root=[1], output=[1]","root=[1,2], output=[2,1]","root=[1,null,2], output=[1,2]","Google, Amazon, Microsoft",Medium,"Tree, DFS",Use recursive or iterative inorder traversal.
71,Unique Binary Search Trees II,"Generate all structurally unique binary search trees (BSTs) for numbers 1 to n. Use recursive construction for O(Catalan(n)) time, handling cases like n=0 or n=1.","n=3, output=[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]","n=1, output=[[1]]","n=2, output=[[1,null,2],[2,1]]","n=0, output=[]","n=4, output=(14 unique BSTs)","Google, Amazon",Medium,"Dynamic Programming, Tree",Generate all unique BSTs using recursion.
72,Unique Binary Search Trees,"Count the number of unique binary search trees possible with n distinct nodes. Use dynamic programming or Catalan numbers for O(n^2) time, handling n=0 or small inputs.","n=3, output=5","n=1, output=1","n=2, output=2","n=0, output=1","n=4, output=14","Google, Amazon",Medium,"Dynamic Programming, Math",Use Catalan numbers or DP for unique BSTs.
73,Interleaving String,"Determine if a string s3 is an interleaving of strings s1 and s2. Use dynamic programming for O(m*n) time, where m and n are string lengths, checking if s3 can be formed by merging s1 and s2.","s1='aabcc', s2='dbbca', s3='aadbbcbcac', output=true","s1='aabcc', s2='dbbca', s3='aadbbbaccc', output=false","s1='', s2='', s3='', output=true","s1='abc', s2='def', s3='adbecf', output=true","s1='a', s2='b', s3='ab', output=true","Google, Amazon",Hard,Dynamic Programming,Use DP to check if s3 is an interleaving of s1 and s2.
74,Validate Binary Search Tree,"Validate if a binary tree is a binary search tree (BST) where left subtree values are less than the node and right subtree values are greater. Use DFS with range checks for O(n) time, handling duplicate values.","root=[2,1,3], output=true","root=[5,1,4,null,null,3,6], output=false","root=[1], output=true","root=[5,4,null,3], output=false","root=[3,1,5], output=true","Google, Amazon, Microsoft",Medium,"Tree, DFS",Check if each node’s value is within valid BST range.
75,Recover Binary Search Tree,"Recover a binary search tree with two swapped nodes by restoring correct BST properties. Use inorder traversal to identify and swap the misplaced nodes in O(n) time, handling minimal trees.","root=[1,3,null,null,2], output=[3,1,null,null,2]","root=[3,1,4,null,null,2], output=[2,1,4,null,null,3]","root=[1], output=[1]","root=[2,1,3], output=[2,1,3]","root=[4,2,6,1,3], output=[4,3,6,1,2]","Google, Amazon",Medium,"Tree, DFS",Find and swap the two nodes that are out of order.
76,Same Tree,"Determine if two binary trees are identical in structure and node values. Compare trees recursively or iteratively in O(n) time, where n is the number of nodes, handling empty or mismatched trees.","p=[1,2,3], q=[1,2,3], output=true","p=[1,2], q=[1,null,2], output=false","p=[1,2,1], q=[1,1,2], output=false","p=[1], q=[1], output=true","p=[], q=[], output=true","Google, Amazon",Easy,"Tree, DFS",Compare trees recursively or iteratively.
77,Symmetric Tree,"Check if a binary tree is symmetric (i.e., its left and right subtrees are mirror images). Use recursive or iterative comparison of mirrored nodes in O(n) time, handling single-node or empty trees.","root=[1,2,2,3,4,4,3], output=true","root=[1,2,2,null,3,null,3], output=false","root=[1], output=true","root=[1,2,2], output=true","root=[1,2,3], output=false","Google, Amazon",Easy,"Tree, DFS",Check if left and right subtrees are mirror images.
78,Binary Tree Level Order Traversal,"Return the level-order traversal of a binary tree, grouping nodes by level. Use BFS with a queue for O(n) time, collecting nodes level by level, handling empty or single-node trees.","root=[3,9,20,null,null,15,7], output=[[3],[9,20],[15,7]]","root=[1], output=[[1]]","root=[], output=[]","root=[1,2,3], output=[[1],[2,3]]","root=[1,null,2], output=[[1],[2]]","Google, Amazon, Microsoft",Medium,"Tree, BFS",Use BFS to traverse level by level.
79,Binary Tree Zigzag Level Order Traversal,"Perform a zigzag level-order traversal of a binary tree, alternating left-to-right and right-to-left. Use BFS with a flag to reverse alternate levels in O(n) time, handling small or empty trees.","root=[3,9,20,null,null,15,7], output=[[3],[20,9],[15,7]]","root=[1], output=[[1]]","root=[], output=[]","root=[1,2,3], output=[[1],[3,2]]","root=[1,null,2,3], output=[[1],[2],[3]]","Google, Amazon",Medium,"Tree, BFS",Use BFS with a flag to reverse alternate levels.
80,Maximum Depth of Binary Tree,"Find the maximum depth of a binary tree (longest root-to-leaf path). Use DFS or BFS for O(n) time, returning 0 for empty trees and handling unbalanced trees.","root=[3,9,20,null,null,15,7], output=3","root=[1,null,2], output=2","root=[1], output=1","root=[], output=0","root=[1,2,3,4,null,null,5], output=3","Google, Amazon",Easy,"Tree, DFS",Use DFS or BFS to find the maximum depth.
81,Construct Binary Tree from Preorder and Inorder Traversal,"Construct a binary tree from its preorder and inorder traversals. Use preorder to identify the root and inorder to split subtrees, building the tree in O(n) time with a hash map for efficiency.","preorder=[3,9,20,15,7], inorder=[9,3,15,20,7], output=[3,9,20,null,null,15,7]","preorder=[1], inorder=[1], output=[1]","preorder=[1,2], inorder=[2,1], output=[1,2]","preorder=[1,2,3], inorder=[2,1,3], output=[1,2,3]","preorder=[3,1,2], inorder=[1,3,2], output=[3,1,2]","Google, Amazon",Medium,"Tree, DFS",Use preorder for root and inorder to split subtrees.
82,Construct Binary Tree from Inorder and Postorder Traversal,"Construct a binary tree from its inorder and postorder traversals. Use postorder to identify the root and inorder to split subtrees, constructing the tree in O(n) time with a hash map.","inorder=[9,3,15,20,7], postorder=[9,15,7,20,3], output=[i3,9,20,null,null,15,7]","inorder=[1], postorder=[1], output=[1]","inorder=[2,1], postorder=[2,1], output=[1,2]","inorder=[2,1,3], postorder=[2,3,1], output=[1,2,3]","inorder=[1,3,2], postorder=[1,2,3], output=[3,1,2]","Google, Amazon",Medium,"Tree, DFS",Use postorder for root and inorder to split subtrees.
83,Binary Tree Level Order Traversal II,"Return the level-order traversal of a binary tree from bottom to top. Use BFS and reverse the result in O(n) time, handling empty trees or single-level trees.","root=[3,9,20,null,null,15,7], output=[[15,7],[9,20],[3]]","root=[1], output=[[1]]","root=[], output=[]","root=[1,2,3], output=[[2,3],[1]]","root=[1,null,2], output=[[2],[1]]","Google, Amazon",Medium,"Tree, BFS",Use BFS and reverse the result.
84,Convert Sorted Array to Binary Search Tree,"Convert a sorted array into a height-balanced binary search tree. Choose the middle element as the root for each subtree in O(n) time, ensuring balance for small or single-element arrays.","nums=[-10,-3,0,5,9], output=[0,-3,9,-10,null,5]","nums=[1,3], output=[3,1]","nums=[1], output=[1]","nums=[1,2,3], output=[2,1,3]","nums=[0], output=[0]","Google, Amazon",Easy,"Tree, DFS",Use middle element as root to balance the BST.
85,Convert Sorted List to Binary Search Tree,"Convert a sorted linked list into a height-balanced binary search tree. Find the middle node for each subtree in O(n log n) time, or optimize to O(n) with a fast-slow pointer approach.","head=[-10,-3,0,5,9], output=[0,-3,9,-10,null,5]","head=[], output=[]","head=[0], output=[0]","head=[1,3], output=[3,1]","head=[1,2,3], output=[2,1,3]","Google, Amazon",Medium,"Linked List, Tree",Find the middle of the list for the root.
86,Balanced Binary Tree,"Determine if a binary tree is height-balanced, where the height difference between subtrees is at most 1. Use DFS to compute heights in O(n) time, checking balance for each node.","root=[3,9,20,null,null,15,7], output=true","root=[1,2,2,3,3,null,null,4,4], output=false","root=[1], output=true","root=[1,2], output=true","root=[1,null,2], output=true","Google, Amazon",Easy,"Tree, DFS",Check if subtree height difference is at most 1.
87,Minimum Depth of Binary Tree,"Find the minimum depth of a binary tree (shortest root-to-leaf path). Use BFS for O(n) time to find the first leaf, handling unbalanced or empty trees.","root=[3,9,20,null,null,15,7], output=2","root=[2,null,3,null,4,null,5,null,6], output=5","root=[1], output=1","root=[1,2], output=2","root=[1,null,2], output=2","Google, Amazon",Easy,"Tree, DFS, BFS",Use BFS for the shortest path to a leaf.
88,Path Sum,"Check if a binary tree has a root-to-leaf path summing to a target value. Use DFS to explore paths in O(n) time, handling negative numbers and empty trees.","root=[5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum=22, output=true","root=[1,2,3], targetSum=5, output=false","root=[1], targetSum=1, output=true","root=[1,2], targetSum=3, output=true","root=[], targetSum=0, output=false","Google, Amazon",Easy,"Tree, DFS",Check if any root-to-leaf path sums to target.
89,Path Sum II,"Find all root-to-leaf paths in a binary tree where the sum equals a target value. Use DFS with backtracking to collect valid paths in O(n) time, handling cases with no valid paths.","root=[5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum=22, output=[[5,4,11,2],[5,8,4,5]]","root=[1,2,3], targetSum=5, output=[]","root=[1], targetSum=1, output=[[1]]","root=[1,2], targetSum=3, output=[[1,2]]","root=[1,null,2], targetSum=3, output=[[1,2]]","Google, Amazon",Medium,"Tree, DFS",Use DFS to collect all paths summing to target.
90,Flatten Binary Tree to Linked List,Flatten a binary tree into a linked list in-place using preorder traversal. Restructure the tree by setting left pointers to null and linking right pointers in O(n) time.,"root=[1,2,5,3,4,null,6], output=[1,null,2,null,3,null,4,null,5,null,6]","root=[1], output=[1]","root=[], output=[]","root=[1,2], output=[1,null,2]","root=[1,null,2], output=[1,null,2]","Google, Amazon",Medium,"Tree, DFS",Flatten the tree in-place using preorder traversal.
91,Populating Next Right Pointers in Each Node,"Connect the next pointers of nodes at the same level in a perfect binary tree. Use BFS or constant space by leveraging next pointers in O(n) time, handling single-node or empty trees.","root=[1,2,3,4,5,6,7], output=[1,#,2,3,#,4,5,6,7,#]","root=[1], output=[1,#]","root=[], output=[]","root=[1,2,3], output=[1,#,2,3,#]","root=[1,null,2], output=[1,#,2,#]","Google, Amazon",Medium,"Tree, BFS",Connect nodes at the same level using next pointers.
92,Populating Next Right Pointers in Each Node II,"Connect the next pointers of nodes at the same level in any binary tree. Use BFS or optimized constant space with next pointers in O(n) time, handling non-perfect trees.","root=[1,2,3,4,5,null,7], output=[1,#,2,3,#,4,5,7,#]","root=[1], output=[1,#]","root=[], output=[]","root=[1,2,3], output=[1,#,2,3,#]","root=[1,null,2], output=[1,#,2,#]","Google, Amazon",Medium,"Tree, BFS",Connect nodes at the same level in a non-perfect tree.
93,Pascal's Triangle,"Generate the first n rows of Pascal’s triangle, where each number is the sum of the two numbers above it. Build each row iteratively in O(n^2) time, handling n=0 or n=1.","numRows=5, output=[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]","numRows=1, output=[[1]]","numRows=2, output=[[1],[1,1]]","numRows=3, output=[[1],[1,1],[1,2,1]]","numRows=0, output=[]","Google, Amazon",Easy,Array,Generate rows using previous row’s values.
94,Pascal's Triangle II,"Generate the kth row of Pascal’s triangle using only O(k) extra space. Compute the row iteratively in O(k) time, handling cases like k=0 or k=1.","rowIndex=3, output=[1,3,3,1]","rowIndex=0, output=[1]","rowIndex=1, output=[1,1]","rowIndex=2, output=[1,2,1]","rowIndex=4, output=[1,4,6,4,1]","Google, Amazon",Easy,Array,Compute the kth row using only O(k) space.
95,Triangle,"Find the minimum path sum from top to bottom in a triangle of numbers, moving to adjacent numbers in the next row. Use dynamic programming for O(n^2) time and O(n) space, where n is the number of rows.","triangle=[[2],[3,4],[6,5,7],[4,1,8,3]], output=11","triangle=[[1]], output=1","triangle=[[1],[2,3]], output=3","triangle=[[1],[2,3],[4,5,6]], output=8","triangle=[[-10]], output=-10","Google, Amazon",Medium,Dynamic Programming,Use DP to find the minimum path sum.
96,Best Time to Buy and Sell Stock,"Find the maximum profit from buying and selling a stock once, given an array of daily prices. Track the minimum price and maximum profit in O(n) time, handling cases with no profit.","prices=[7,1,5,3,6,4], output=5","prices=[7,6,4,3,1], output=0","prices=[1], output=0","prices=[1,2], output=1","prices=[2,1,4], output=3","Google, Amazon, Facebook",Easy,"Array, Dynamic Programming",Track minimum price and maximum profit.
97,Best Time to Buy and Sell Stock II,"Maximize profit by buying and selling a stock multiple times, given daily prices, without overlapping transactions. Sum all positive price differences in O(n) time, handling decreasing prices.","prices=[7,1,5,3,6,4], output=7","prices=[1,2,3,4,5], output=4","prices=[7,6,4,3,1], output=0","prices=[1], output=0","prices=[2,1,2,0,1], output=2","Google, Amazon",Medium,"Array, Greedy",Sum all positive price differences.
98,Binary Tree Maximum Path Sum,"Find the maximum path sum in a binary tree, where the path can include any node-to-node segment. Use DFS to track maximum sums through each node in O(n) time, handling negative values.","root=[1,2,3], output=6","root=[-10,9,20,null,null,15,7], output=42","root=[1], output=1","root=[-1,-2,-3], output=-1","root=[2,-1], output=2","Google, Amazon",Hard,"Tree, DFS",Track maximum path sum through each node.
99,Valid Palindrome,"Determine if a string is a palindrome, ignoring non-alphanumeric characters and case. Use two pointers to compare valid characters in O(n) time, handling empty or single-character strings.","s='A man, a plan, a canal: Panama', output=true","s='race a car', output=false","s=' ', output=true","s='ab', output=false","s='a', output=true","Google, Amazon",Easy,"String, Two Pointers",Ignore non-alphanumeric characters and compare.
100,Word Ladder II,"Find all shortest transformation sequences from a start word to an end word, changing one letter at a time via a word list. Use BFS to find shortest paths and backtracking for all sequences in O(n*26^l) time, where l is word length.","beginWord='hit', endWord='cog', wordList=['hot','dot','dog','lot','log','cog'], output=[['hit','hot','dot','dog','cog'],['hit','hot','lot','log','cog']]","beginWord='hit', endWord='cog', wordList=['hot','dot','dog'], output=[]","beginWord='a', endWord='c', wordList=['a','b','c'], output=[['a','b','c']]","beginWord='red', endWord='tax', wordList=['ted','tex','red','tax'], output=[['red','ted','tex','tax']]","beginWord='hot', endWord='dog', wordList=['hot','dog'], output=[]","Google, Amazon",Hard,"BFS, Backtracking",Use BFS to find shortest paths and backtrack for all paths.
101,Word Ladder,"Find the shortest transformation sequence length from a start word to an end word, changing one letter at a time via a word list. Use BFS for O(n*26^l) time, returning 0 if no sequence exists.","beginWord='hit', endWord='cog', wordList=['hot','dot','dog','lot','log','cog'], output=5","beginWord='hit', endWord='cog', wordList=['hot','dot','dog'], output=0","beginWord='a', endWord='c', wordList=['a','b','c'], output=3","beginWord='red', endWord='tax', wordList=['ted','tex','red','tax'], output=4","beginWord='hot', endWord='dog', wordList=['hot','dog'], output=0","Google, Amazon",Hard,BFS,Use BFS to find the shortest transformation sequence.
102,Longest Consecutive Sequence,"Find the length of the longest consecutive sequence in an unsorted array of integers. Use a hash set for O(n) time lookup, checking sequence starts and lengths, handling duplicates.","nums=[100,4,200,1,3,2], output=4","nums=[0,3,7,2,5,8,4,6,0,1], output=9","nums=[1], output=1","nums=[1,2], output=2","nums=[1,3], output=1","Google, Amazon",Medium,"Array, Hash Table",Use a hash set to find the longest consecutive sequence.
103,Sum Root to Leaf Numbers,"Sum all numbers formed by root-to-leaf paths in a binary tree, where each path represents a number. Use DFS to construct numbers in O(n) time, handling multi-digit nodes and single-node trees.","root=[1,2,3], output=25","root=[4,9,0,5,1], output=1026","root=[1], output=1","root=[1,2], output=12","root=[4,9], output=49","Google, Amazon",Medium,"Tree, DFS",Sum numbers formed by root-to-leaf paths.
104,Surrounded Regions,"Modify a board in-place by flipping surrounded 'O' regions to 'X', where surrounded means no connection to the border. Use DFS from border 'O's to mark connected regions in O(m*n) time, handling small boards.","board=[['X','X','X','X'],['X','O','O','X'],['X','X','O','X'],['X','O','X','X']], output=[['X','X','X','X'],['X','X','X','X'],['X','X','X','X'],['X','O','X','X']]","board=[['X']], output=[['X']]","board=[['O']], output=[['O']]","board=[['X','O'],['O','X']], output=[['X','O'],['O','X']]","board=[['O','O'],['O','O']], output=[['O','O']]","Google, Amazon",Medium,"DFS, Union Find",Mark ‘O’s connected to the border using DFS.
105,Clone Graph,"Clone a graph with nodes having neighbors and random pointers. Use DFS or BFS with a hash map to copy nodes and edges in O(n) time, where n is the number of nodes, handling cyclic graphs.","node=1->[[2,4],[1,3],[2,4],[1,3]], output=cloned graph","node=1->[], output=cloned graph","node=1->[[2],[1]], output=cloned graph","node=1->[[2,3],[1,3],[1,2]], output=cloned graph","node=1->[[2],[1]], output=cloned graph","Google, Amazon",Medium,"Graph, DFS, BFS",Use DFS or BFS to clone the graph with a hash map.
106,Gas Station,"Determine if a car can complete a circuit given gas and cost arrays, returning the starting station index. Check if total gas is sufficient and find the start point in O(n) time, handling single-station cases.","gas=[1,2,3,4,5], cost=[3,4,5,1,2], output=3","gas=[2,3,4], cost=[3,4,3], output=-1","gas=[1], cost=[1], output=0","gas=[2,2], cost=[2,2], output=0","gas=[5,1,2,3,4], cost=[4,1,1,1,1], output=1","Google, Amazon",Medium,"Array, Greedy",Check if total gas is sufficient and find starting point.
107,Candy,"Assign candies to children based on ratings, ensuring higher-rated children get more candies than neighbors. Use two passes (left-to-right and right-to-left) for O(n) time, minimizing total candies.","ratings=[1,0,2], output=5","ratings=[1,2,2], output=4","ratings=[1], output=1","ratings=[1,2], output=3","ratings=[2,1], output=3","Google, Amazon",Hard,"Array, Greedy",Assign candies based on ratings with two passes.
108,Single Number,"Find the single number in an array where every other number appears twice. Use XOR operations for O(n) time and O(1) space, handling single-element arrays.","nums=[2,2,1], output=1","nums=[4,1,2,1,2], output=4","nums=[1], output=1","nums=[1,1,2], output=2","nums=[3,3,4], output=4","Google, Amazon",Easy,"Array, Bit Manipulation",Use XOR to find the single number.
109,Single Number II,"Find the single number in an array where every other number appears three times. Use bit manipulation to track numbers appearing once in O(n) time, handling single-element cases.","nums=[2,2,3,2], output=3","nums=[0,1,0,1,0,1,99], output=99","nums=[1], output=1","nums=[2,2,2,3], output=3","nums=[1,1,1,4], output=4","Google, Amazon",Medium,"Array, Bit Manipulation",Use bit manipulation to track numbers appearing once.
110,Copy List with Random Pointer,"Copy a linked list with random pointers, preserving the structure. Interleave the original and copied nodes for O(n) time and O(1) space, then separate, handling lists with no random pointers.","head=[1,2,3,random=3,1,null], output=copied list","head=[1,null], output=copied list","head=[], output=[]","head=[1,1,random=1], output=copied list","head=[2,3,random=3], output=copied list","Google, Amazon",Medium,Linked List,Interleave nodes to copy with random pointers.
111,Word Break,"Determine if a string can be segmented into words from a dictionary. Use dynamic programming for O(n^2) time with a hash set for word lookup, handling empty strings or dictionaries.","s='leetcode', wordDict=['leet','code'], output=true","s='applepenapple', wordDict=['apple','pen'], output=true","s='catsandog', wordDict=['cats','dog','sand','and','cat'], output=false","s='a', wordDict=['a'], output=true","s='ab', wordDict=['a','b'], output=true","Google, Amazon",Medium,Dynamic Programming,Use DP to check if string can be segmented.
112,Word Break II,"Find all possible word segmentations of a string using a dictionary. Use backtracking or dynamic programming with memoization for O(2^n) time, returning empty lists for invalid cases.","s='catsanddog', wordDict=['cat','cats','and','sand','dog'], output=['cats and dog','cat sand dog']","s='pineapplepenapple', wordDict=['apple','pen','applepen','pine','pineapple'], output=['pine apple pen apple','pineapple pen apple','pine applepen apple']","s='catsandog', wordDict=['cats','dog','sand','and','cat'], output=[]","s='a', wordDict=['a'], output=['a']","s='ab', wordDict=['a','b'], output=['a b']","Google, Amazon",Hard,"Dynamic Programming, Backtracking",Use backtracking or DP to find all segmentations.
113,Linked List Cycle,"Detect if a linked list has a cycle using Floyd’s cycle detection algorithm. Use two pointers (slow and fast) for O(n) time and O(1) space, returning false for empty or acyclic lists.","head=[3,2,0,-4], pos=1, output=true","head=[1,2], pos=0, output=true","head=[1], pos=-1, output=false","head=[1,2,3], pos=-1, output=false","head=[1,2,3,4], pos=2, output=true","Google, Amazon",Easy,"Linked List, Two Pointers",Use Floyd’s cycle detection algorithm.
114,Linked List Cycle II,"Find the node where a cycle begins in a linked list using Floyd’s algorithm. Use two pointers to detect the cycle and locate the entrance in O(n) time, returning null for acyclic lists.","head=[3,2,0,-4], pos=1, output=2","head=[1,2], pos=0, output=1","head=[1], pos=-1, output=null","head=[1,2,3], pos=-1, output=null","head=[1,2,3,4], pos=2, output=3","Google, Amazon",Medium,"Linked List, Two Pointers",Use Floyd’s algorithm to find the cycle’s start.
115,Reorder List,"Reorder a linked list by interleaving the first half with the reversed second half. Find the middle, reverse the second half, and merge in O(n) time, handling odd or even-length lists.","head=[1,2,3,4], output=[1,4,2,3]","head=[1,2,3,4,5], output=[1,5,2,4,3]","head=[1], output=[1]","head=[1,2], output=[1,2]","head=[1,2,3], output=[1,3,2]","Google, Amazon",Medium,Linked List,"Find middle, reverse second half, and merge."
116,Binary Tree Preorder Traversal,"Return the preorder traversal of a binary tree (root, left, right). Use recursive or iterative (stack-based) traversal for O(n) time, handling empty or single-node trees.","root=[1,null,2,3], output=[1,2,3]","root=[], output=[]","root=[1], output=[1]","root=[1,2], output=[1,2]","root=[1,null,2], output=[1,2]","Google, Amazon",Medium,"Tree, DFS",Use recursive or iterative preorder traversal.
117,Binary Tree Postorder Traversal,"Return the postorder traversal of a binary tree (left, right, root). Use recursive or iterative (stack-based) traversal for O(n) time, handling empty or single-node trees.","root=[1,null,2,3], output=[3,2,1]","root=[], output=[]","root=[1], output=[1]","root=[1,2], output=[2,1]","root=[1,null,2], output=[2,1]","Google, Amazon",Medium,"Tree, DFS",Use recursive or iterative postorder traversal.
118,LRU Cache,"Implement an LRU (Least Recently Used) cache with get and put operations in O(1) time. Use a hash map and doubly linked list to track and evict the least recently used items, handling capacity constraints.","ops=['LRUCache','put','put','get','put','get','put','get','get','get'], args=[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]], output=[null,null,null,1,null,-1,null,-1,3,4]","ops=['LRUCache','put','get'], args=[[1],[1,1],[1]], output=[null,null,1]","ops=['LRUCache','get'], args=[[1],[1]], output=[null,-1]","ops=['LRUCache','put','put','get'], args=[[1],[1,1],[2,2],[1]], output=[null,null,null,1]","ops=['LRUCache','put','put','get'], args=[[2],[1,1],[2,2],[3]], output=[null,null,null,-1]","Google, Amazon",Medium,"Design, Hash Table, Linked List",Use a hash map and doubly linked list for O(1) operations.
119,Insertion Sort List,"Sort a linked list using insertion sort. Insert each node into its correct position in a sorted sublist for O(n^2) time, handling duplicates or single-node lists.","head=[4,2,1,3], output=[1,2,3,4]","head=[-1,5,3,4,0], output=[-1,0,3,4,5]","head=[1], output=[1]","head=[2,1], output=[1,2]","head=[1,1,1], output=[1,1,1]","Google, Amazon",Medium,"Linked List, Sorting",Implement insertion sort on a linked list.
120,Sort List,"Sort a linked list in O(n log n) time using merge sort. Split the list, sort recursively, and merge sorted halves, handling empty or single-node lists.","head=[4,2,1,3], output=[1,2,3,4]","head=[-1,5,3,4,0], output=[-1,0,3,4,5]","head=[1], output=[1]","head=[2,1], output=[1,2]","head=[1,1,1], output=[1,1,1]","Google, Amazon",Medium,"Linked List, Sorting",Use merge sort for O(n log n) time.
121,Max Points on a Line,"Find the maximum number of points that lie on the same line in a 2D plane. Calculate slopes between pairs of points using a hash map for O(n^2) time, handling duplicate points and vertical lines.","points=[[1,1],[2,2],[3,3]], output=3","points=[[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]], output=4","points=[[1,1]], output=1","points=[[1,1],[2,2]], output=2","points=[[0,0],[1,1],[0,0]], output=3","Google, Amazon",Hard,"Math, Geometry",Calculate slopes to find collinear points.
122,Evaluate Reverse Polish Notation,"Evaluate a Reverse Polish Notation (postfix) expression using a stack. Process operands and operators in O(n) time, handling valid expressions with integers and basic operators (+, -, *, /).","tokens=['2','1','+','3','*'], output=9","tokens=['4','13','5','/','+'], output=6","tokens=['10','6','9','3','+','-11','*','/','*','17','+','5','+'], output=22","tokens=['1'], output=1","tokens=['2','3','*'], output=6","Google, Amazon",Medium,Stack,Use a stack to evaluate postfix expressions.
123,Reverse Words in a String,"Reverse the order of words in a string, removing extra spaces. Split the string, reverse the words, and join with single spaces in O(n) time, handling leading/trailing spaces or single words.","s='the sky is blue', output='blue is sky the'","s='  hello world  ', output='world hello'","s='a', output='a'","s='  a  b  ', output='b a'","s='hi!', output='hi!'","Google, Amazon",Medium,String,"Split the string, reverse words, and join with single spaces."
124,Maximum Product Subarray,"Find the maximum product of a contiguous subarray in an array. Track maximum and minimum products due to negative numbers in O(n) time, handling zero or single-element arrays.","nums=[2,3,-2,4], output=6","nums=[-2,0,-1], output=0","nums=[1], output=1","nums=[-2,-3], output=6","nums=[2,3,-2], output=6","Google, Amazon",Medium,"Array, Dynamic Programming",Track max and min products due to negative numbers.
125,Find Minimum in Rotated Sorted Array,"Find the minimum element in a rotated sorted array with no duplicates. Use binary search for O(log n) time, leveraging the sorted structure to locate the pivot.","nums=[3,4,5,1,2], output=1","nums=[4,5,6,7,0,1,2], output=0","nums=[1], output=1","nums=[2,1], output=1","nums=[3,1,2], output=1","Google, Amazon",Medium,"Array, Binary Search",Use binary search to find the minimum.
126,Find Minimum in Rotated Sorted Array II,"Find the minimum element in a rotated sorted array that may contain duplicates. Use modified binary search for O(n) worst-case time due to duplicates, handling single-element arrays.","nums=[1,3,5], output=1","nums=[2,2,2,0,1], output=0","nums=[1], output=1","nums=[2,2,2], output=2","nums=[3,3,1,3], output=1","Google, Amazon",Hard,"Array, Binary Search",Handle duplicates with modified binary search.
127,Min Stack,"Design a stack that supports push, pop, top, and getMin operations in O(1) time. Use two stacks to track values and minimums, handling empty stack scenarios.","ops=['MinStack','push','push','push','getMin','pop','top','getMin'], args=[[],[-2],[0],[-3],[-3],[0],[-2]], output=[null,null,null,null,-3,null,0,-2]","ops=['MinStack','push','getMin'], args=[],[1], output=[null,null,1]","ops=['MinStack','push','pop','getMin'], args=[],[1], output=[null,null,null,null]","ops=['MinStack','push','push','getMin'], args=[],[1],[2], output=[null,null,null,1]","ops=['MinStack','push','top'], args=[],[3], output=[null,null,3]","Google, Amazon",Easy,"Stack, Design",Use two stacks to track values and minimums.
128,Intersection of Two Linked Lists,"Find the intersection node of two linked lists, if it exists. Use two pointers to align lists by length in O(n+m) time and O(1) space, returning null if no intersection exists.","headA=[4,1,8,4,5], headB=[5,6,1,8,4,5], intersect=8, output=8","headA=[1,9,1,2,4], headB=[3,2,4], intersect=2, output=2","headA=[2,6,4], headB=[1,5], intersect=null, output=null","headA=[1], headB=[1], intersect=1, output=1","headA=[1,2], headB=[1,2], intersect=2, output=2","Google, Amazon",Easy,"Linked List, Two Pointers",Find intersection by aligning lists with equal lengths.
129,Find Peak Element,"Find any index of a peak element in an array where it is greater than its neighbors. Use binary search for O(log n) time, handling single-element or edge cases.","nums=[1,2,3,1], output=2","nums=[1,2,1,3,5,6,4], output=1 or 5","nums=[1], output=0","nums=[1,2], output=1","nums=[2,1], output=0","Google, Amazon",Medium,"Array, Binary Search",Use binary search to find a peak element.
130,Compare Version Numbers,"Compare two version strings (e.g., '1.01' vs '1.001') and return -1, 0, or 1. Split versions into segments and compare numerically in O(n) time, handling unequal lengths or leading zeros.","version1='1.01', version2='1.001', output=0","version1='1.0', version2='1.0.0', output=0","version1='0.1', version2='1.1', output=-1","version1='1.0.1', version2='1', output=1","version1='7.5.2.4', version2='7.5.3', output=-1","Google, Amazon",Medium,String,Split versions and compare segments.
131,Fraction to Recurring Decimal,"Convert a fraction to a decimal string, capturing repeating decimals in parentheses. Use long division with a hash map to detect repeating remainders in O(n) time, handling negative numbers.","numerator=1, denominator=2, output='0.5'","numerator=2, denominator=1, output='2'","numerator=2, denominator=3, output='0.(6)'","numerator=4, denominator=333, output='0.(012)'","numerator=-1, denominator=2, output='-0.5'","Google, Amazon",Medium,"Math, Hash Table",Track remainders to detect repeating decimals.
132,Two Sum II - Input Array Is Sorted,"Find indices of two numbers in a sorted array that add up to a target. Use two pointers for O(n) time, leveraging the sorted order, assuming exactly one solution exists.","numbers=[2,7,11,15], target=9, output=[1,2]","numbers=[2,3,4], target=6, output=[1,3]","numbers=[-1,0], target=-1, output=[1,2]","numbers=[1,2,3], target=5, output=[2,3]","numbers=[0,0,3,4], target=0, output=[1,2]","Google, Amazon",Easy,"Array, Two Pointers",Use two pointers on sorted array.
133,Excel Sheet Column Title,"Convert a positive integer to its corresponding Excel column title (base-26). Compute the title using division and modulo in O(log n) time, handling cases like 1=A, 26=Z, 27=AA.","columnNumber=1, output='A'","columnNumber=28, output='AB'","columnNumber=701, output='ZY'","columnNumber=26, output='Z'","columnNumber=27, output='AA'","Google, Amazon",Easy,Math,Convert number to base-26 representation.
134,Majority Element,"Find the majority element in an array that appears more than n/2 times. Use Boyer-Moore voting algorithm for O(n) time and O(1) space, assuming a majority exists.","nums=[3,2,3], output=3","nums=[2,2,1,1,1,2,2], output=2","nums=[1], output=1","nums=[1,1], output=1","nums=[2,2,2,1], output=2","Google, Amazon",Easy,"Array, Boyer-Moore Voting",Use Boyer-Moore voting algorithm.
135,Excel Sheet Column Number,"Convert an Excel column title (e.g., 'AB') to its corresponding column number (base-26). Compute the number by treating the title as a base-26 string in O(n) time, handling single or multi-character titles.","columnTitle='A', output=1","columnTitle='AB', output=28","columnTitle='ZY', output=701","columnTitle='Z', output=26","columnTitle='AA', output=27","Google, Amazon",Easy,Math,Convert base-26 string to number.
136,Factorial Trailing Zeroes,"Count the number of trailing zeros in n!. Calculate the number of factors of 5 in O(log n) time, as they limit the number of 10s formed with factors of 2.","n=5, output=1","n=0, output=0","n=3, output=0","n=10, output=2","n=25, output=6","Google, Amazon",Easy,Math,Count factors of 5 in factorial.
137,Binary Search Tree Iterator,"Implement an iterator for inorder traversal of a binary search tree. Use a stack to track nodes for O(1) average time per call and O(h) space, where h is the tree height.","root=[7,3,15,null,null,9,20], ops=['BSTIterator','next','next','hasNext'], output=[null,3,7,true]","root=[1], ops=['BSTIterator','next','hasNext'], output=[null,1,false]","root=[3,1,4], ops=['BSTIterator','next'], output=[null,1]","root=[3,null,4], ops=['BSTIterator','next'], output=[null,3]","root=[5,3,7], ops=['BSTIterator','next','next'], output=[null,3,5]","Google, Amazon",Medium,"Tree, Design",Use a stack for inorder traversal.
138,Dungeon Game,"Calculate the minimum initial health needed to navigate a dungeon grid with positive/negative values to reach the bottom-right. Use dynamic programming for O(m*n) time, computing health backward from the goal.","dungeon=[[-2,-3,3],[-5,-10,1],[10,30,-5]], output=7","dungeon=[[0]], output=1","dungeon=[[100]], output=1","dungeon=[[-1]], output=2","dungeon=[[1,-2],[3,-4]], output=2","Google, Amazon",Hard,Dynamic Programming,Use DP to compute minimum health needed.
139,Largest Number,"Form the largest possible number by concatenating an array of integers. Sort numbers by a custom comparator for O(n log n) time, handling cases with zeros or single numbers.","nums=[10,2], output='210'","nums=[3,30,34,5,9], output='9534330'","nums=[1], output='1'","nums=[0,0], output='0'","nums=[23,45,67], output='674523'","Google, Amazon",Medium,"String, Sorting",Sort numbers by custom comparator for largest concatenation.
140,Repeated DNA Sequences,"Find all 10-length DNA sequences that appear more than once in a string. Use a hash set or rolling hash for O(n) time, returning sequences in any order, handling short or non-repeating strings.","s='AAAAACCCCCAAAAACCCCCC', output=['AAAAACCCCC']","s='AAAAAAAAAAA', output=['AAAAAAAAAA']","s='AAAAAAAAAA', output=[]","s='AABBCCDDEE', output=[]","s='AAAAAABB', output=[]","Google, Amazon",Medium,"String, Hash Table",Use a hash set to find repeated 10-length substrings.
141,Rotate Array,"Rotate an array to the right by k steps in-place. Use reverse operations (reverse all, then first k, then rest) for O(n) time and O(1) space, handling k larger than array length.","nums=[1,2,3,4,5,6,7], k=3, output=[5,6,7,1,2,3,4]","nums=[-1,-100,3,99], k=2, output=[3,99,-1,-100]","nums=[1], k=0, output=[1]","nums=[1,2], k=1, output=[2,1]","nums=[1,2,3], k=4, output=[3,1,2]","Google, Amazon",Medium,Array,Use reverse operations to rotate in-place.
142,Reverse Bits,"Reverse the bits of a 32-bit unsigned integer. Use bitwise operations to swap bits in O(1) time (32 iterations), handling edge cases like 0 or all 1s.","n=43261596, output=964176192","n=4294967293, output=3221225471","n=0, output=0","n=1, output=2147483648","n=2, output=1073741824","Google, Amazon",Easy,Bit Manipulation,Reverse bits using bitwise operations.
143,Number of 1 Bits,"Count the number of 1 bits in a 32-bit unsigned integer. Use bitwise operations for O(1) time (32 iterations), handling cases like 0 or maximum integer.","n=11, output=3","n=128, output=1","n=4294967295, output=32","n=0, output=0","n=1, output=1","Google, Amazon",Easy,Bit Manipulation,Count set bits using bitwise operations.
144,House Robber,"Maximize loot by robbing non-adjacent houses in an array of money values. Use dynamic programming for O(n) time and O(1) space, choosing to rob or skip each house.","nums=[1,2,3,1], output=4","nums=[2,7,9,3,1], output=12","nums=[1], output=1","nums=[2,1], output=2","nums=[1,2], output=2","Google, Amazon",Medium,Dynamic Programming,Use DP to maximize loot without adjacent houses.
145,Binary Tree Right Side View,"Return the rightmost nodes at each level of a binary tree (right side view). Use BFS or DFS with level tracking for O(n) time, handling skewed or single-node trees.","root=[1,2,3,null,5,null,4], output=[1,3,4]","root=[1,null,3], output=[1,3]","root=[1], output=[1]","root=[1,2], output=[1,2]","root=[1,null,2,null,3], output=[1,2,3]","Google, Amazon",Medium,"Tree, BFS, DFS",Use BFS or DFS to collect rightmost nodes per level.
146,Number of Islands,"Count the number of islands (connected '1's) in a 2D binary grid. Use DFS or BFS to mark connected components in O(m*n) time, handling empty or single-cell grids.","grid=[['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']], output=3","grid=[['1']], output=1","grid=[['0']], output=0","grid=[['1','0'],['0','1']], output=2","grid=[['1','1'],['1','1']], output=1","Google, Amazon, Microsoft",Medium,"DFS, BFS, Union Find",Count connected components of ‘1’s using DFS or BFS.
147,Bitwise AND of Numbers Range,"Find the bitwise AND of all numbers in a range [left, right]. Compute the common prefix of binary representations in O(log n) time, handling cases where left equals right.","left=5, right=7, output=4","left=0, right=0, output=0","left=1, right=2147483647, output=0","left=2, right=3, output=2","left=6, right=7, output=6","Google, Amazon",Medium,Bit Manipulation,Find common prefix of binary representations.
148,Happy Number,"Determine if a number is happy by checking if the sum of squares of its digits eventually reaches 1. Use a hash set to detect cycles in O(log n) time, handling single-digit cases.","n=19, output=true","n=2, output=false","n=7, output=true","n=1, output=true","n=23, output=true","Google, Amazon",Easy,"Math, Hash Table",Detect cycle in sum of squared digits.
149,Remove Linked List Elements,"Remove all nodes with a given value from a linked list. Traverse the list, adjusting pointers to skip matching nodes in O(n) time, handling cases where all nodes are removed.","head=[1,2,6,3,4,6], val=6, output=[1,2,3,4]","head=[1], val=1, output=[]","head=[7,7,7,7], val=7, output=[]","head=[1,2,3], val=4, output=[1,2,3]","head=[1,1], val=1, output=[]","Google, Amazon",Easy,Linked List,Remove nodes with the given value.
150,Count Primes,"Count the number of prime numbers less than n. Use the Sieve of Eratosthenes for O(n log log n) time, handling small inputs like n=0 or n=1.","n=10, output=4","n=0, output=0","n=1, output=0","n=2, output=0","n=15, output=6","Google, Amazon",Medium,Math,Use Sieve of Eratosthenes to count primes.
151,Isomorphic Strings,"Check if two strings are isomorphic, meaning characters map one-to-one between them. Use a hash map to track mappings in O(n) time, ensuring bijection and handling equal strings.","s='egg', t='add', output=true","s='foo', t='bar', output=false","s='paper', t='title', output=true","s='badc', t='baba', output=false","s='egg', t='egg', output=true","Google, Amazon",Easy,"String, Hash Table",Map characters from s to t for one-to-one mapping.
152,Reverse Linked List,"Reverse a singly linked list. Adjust pointers iteratively or recursively in O(n) time and O(1) space, handling empty or single-node lists.","head=[1,2,3,4,5], output=[5,4,3,2,1]","head=[1,2], output=[2,1]","head=[1], output=[1]","head=[], output=[]","head=[1,2,3], output=[3,2,1]","Google, Amazon",Easy,Linked List,Reverse pointers iteratively or recursively.
153,Course Schedule,"Determine if a course schedule with prerequisites can be completed without cycles. Use DFS or BFS to detect cycles in the directed graph in O(V+E) time, where V is courses and E is prerequisites.","numCourses=2, prerequisites=[[1,0]], output=true","numCourses=2, prerequisites=[[1,0],[0,1]], output=false","numCourses=1, prerequisites=[], output=true","numCourses=3, prerequisites=[[1,0],[2,1]], output=true","numCourses=3, prerequisites=[[1,0],[0,2],[2,1]], output=false","Google, Amazon",Medium,"Graph, DFS, BFS",Detect cycle in a directed graph.
154,Implement Trie (Prefix Tree),"Implement a trie with insert, search, and startsWith operations for strings. Use a trie node structure for O(m) time per operation, where m is the word length, handling empty or prefix queries.","ops=['Trie','insert','search','search','startsWith','insert','search'], args=[[],['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']], output=[null,null,true,false,true,null,true]","ops=['Trie','insert','search'], args=[[],['apple'],['apple']], output=[null,null,true]","ops=['Trie','search'], args=[[],['a']], output=[null,false]","ops=['Trie','insert','startsWith'], args=[[],['apple'],['app']], output=[null,null,true]","ops=['Trie','insert','search'], args=[[],['a'],['a']], output=[null,null,true]","Google, Amazon, Microsoft",Medium,"Trie, Design","Implement trie with insert, search, and startsWith."
155,Minimum Size Subarray Sum,"Find the shortest subarray with a sum at least equal to a target. Use a sliding window for O(n) time, tracking the minimum length and handling cases with no solution.","target=7, nums=[2,3,1,2,4,3], output=2","target=4, nums=[1,4,4], output=1","target=11, nums=[1,1,1,1,1,1,1,1], output=0","target=3, nums=[1,2], output=2","target=6, nums=[1,2,3], output=2","Google, Amazon",Medium,"Array, Sliding Window",Use sliding window to find shortest subarray.
156,Course Schedule II,"Find a valid order to take courses with prerequisites, or return empty if impossible. Use topological sort with DFS or BFS for O(V+E) time, handling acyclic and cyclic graphs.","numCourses=2, prerequisites=[[1,0]], output=[0,1]","numCourses=4, prerequisites=[[1,0],[2,0],[3,1],[3,2]], output=[0,2,1,3]","numCourses=1, prerequisites=[], output=[0]","numCourses=2, prerequisites=[[1,0],[0,1]], output=[]","numCourses=3, prerequisites=[[1,0],[2,1]], output=[0,1,2]","Google, Amazon",Medium,"Graph, DFS, BFS",Use topological sort to order courses.
157,Design Add and Search Words Data Structure,"Design a data structure to add words and search with wildcards ('.' for any character). Use a trie with DFS for O(m*26^w) time for search, where m is word length and w is wildcards.","ops=['WordDictionary','addWord','addWord','addWord','search'], args=[[],['bad'],['dad'],['mad'],['pad']], output=[null,null,null,null,false]","ops=['WordDictionary','addWord','search'], args=[[],['bad'],['bad']], output=[null,null,true]","ops=['WordDictionary','addWord','search'], args=[[],['bad'],['.ad']], output=[null,null,true]","ops=['WordDictionary','addWord','search'], args=[[],['bad'],['b..']], output=[null,null,true]","ops=['WordDictionary','search'], args=[[],['a']], output=[null,false]","Google, Amazon",Medium,"Trie, Design",Use trie with DFS for wildcard search.
158,Word Search II,"Find all words from a list that can be formed by adjacent letters in a 2D board. Use a trie with DFS for O(n*m*4^w) time, where w is the maximum word length, optimizing with prefix matching.","board=[['o','a','a','n'],['e','t','a','e'],['i','h','k','r'],['i','f','l','v']], words=['oath','pea','eat','rain'], output=['eat','oath']","board=[['a','b'],['c','d']], words=['ab','cb','ad','bd','ac','ca','da','bc','db','adcb','dabc','abb','acb'], output=['ab','ac','bd','ca','db']","board=[['a']], words=['a'], output=['a']","board=[['a','b']], words=['ab','ba'], output=['ab']","board=[['a']], words=['b'], output=[]","Google, Amazon",Hard,"Trie, Backtracking",Use trie to optimize word search.
159,House Robber II,"Maximize loot in a circular array of houses, where first and last houses are adjacent. Use dynamic programming with two cases (excluding first or last house) for O(n) time, handling single houses.","nums=[2,3,2], output=3","nums=[1,2,3,1], output=4","nums=[1], output=1","nums=[1,2], output=2","nums=[2,1,1,2], output=3","Google, Amazon",Medium,Dynamic Programming,Handle circular array by considering two cases.
160,Kth Largest Element in an Array,"Find the kth largest element in an unsorted array. Use a min-heap or quickselect for O(n log k) or O(n) average time, handling duplicates and k=1 or k=n cases.","nums=[3,2,1,5,6,4], k=2, output=5","nums=[3,2,3,1,2,4,5,5,6], k=4, output=4","nums=[1], k=1, output=1","nums=[1,2], k=1, output=2","nums=[2,1], k=2, output=1","Google, Amazon",Medium,"Array, Heap, Quickselect",Use a min-heap or quickselect to find kth largest.
161,Combination Sum III,"Find all combinations of k numbers from 1 to 9 that sum to n. Use backtracking for O(9 choose k) time, ensuring numbers are used once and handling invalid cases.","k=3, n=7, output=[[1,2,4]]","k=3, n=9, output=[[1,2,6],[1,3,5],[2,3,4]]","k=4, n=1, output=[]","k=2, n=5, output=[[1,4],[2,3]]","k=1, n=1, output=[[1]]","Google, Amazon",Medium,Backtracking,Use backtracking to find combinations of k numbers summing to n.
162,Contains Duplicate,"Check if an array contains any duplicate elements. Use a hash set for O(n) time, returning true if any number appears more than once, handling empty or single-element arrays.","nums=[1,2,3,1], output=true","nums=[1,2,3,4], output=false","nums=[1], output=false","nums=[1,1], output=true","nums=[1,2], output=false","Google, Amazon",Easy,"Array, Hash Table",Use a hash set to check for duplicates.
163,Contains Duplicate II,"Check if an array has two identical elements within k indices of each other. Use a hash map to track indices in O(n) time, handling cases where k exceeds array length.","nums=[1,2,3,1], k=3, output=true","nums=[1,0,1,1], k=1, output=true","nums=[1,2,3,1,2,3], k=2, output=false","nums=[1], k=1, output=false","nums=[1,1], k=1, output=true","Google, Amazon",Easy,"Array, Hash Table",Track indices in a hash map within distance k.
164,Maximal Square,"Find the area of the largest square of 1s in a binary matrix. Use dynamic programming to track square sizes in O(m*n) time, handling single-cell or empty matrices.","matrix=[['1','0','1','0','0'],['1','0','1','1','1'],['1','1','1','1','1'],['1','0','0','1','0']], output=4","matrix=[['0']], output=0","matrix=[['1']], output=1","matrix=[['1','0'],['0','1']], output=1","matrix=[['1','1'],['1','1']], output=4","Google, Amazon",Medium,Dynamic Programming,Use DP to find the largest square of ‘1’s.
165,Count Complete Tree Nodes,"Count the number of nodes in a complete binary tree. Use binary search on tree height for O(log^2 n) time, leveraging complete tree properties, or DFS for O(n) time.","root=[1,2,3,4,5,6], output=6","root=[1], output=1","root=[], output=0","root=[1,2,3], output=3","root=[1,null,2], output=2","Google, Amazon",Medium,"Tree, Binary Search",Use binary search on complete tree properties.
166,Rectangle Area,"Compute the total area of two rectangles minus their overlapping area. Calculate each rectangle’s area and subtract the intersection in O(1) time, handling non-overlapping or identical rectangles.","ax1=-3, ay1=0, ax2=3, ay2=4, bx1=0, by1=-1, bx2=9, by2=2, output=45","ax1=-2, ay1=-2, ax2=2, ay2=2, bx1=-2, by1=-2, bx2=2, by2=2, output=16","ax1=0, ay1=0, ax2=1, ay2=1, bx1=1, by1=1, bx2=2, by2=2, output=2","ax1=-2, ay1=-2, ax2=2, ay2=2, bx1=3, by1=3, bx2=4, by2=4, output=17","ax1=0, ay1=0, ax2=1, ay2=1, bx1=2, by1=2, bx2=3, by2=3, output=2","Google, Amazon",Medium,"Math, Geometry",Calculate total area minus overlapping area.
167,Basic Calculator,"Evaluate a string expression with addition, subtraction, and parentheses. Use a stack to handle signs and parentheses in O(n) time, parsing numbers and operators correctly.","s='1 + 1', output=2","s=' 2-1 + 2 ', output=3","s='(1+(4+5+2)-3)+(6+8)', output=23","s='1', output=1","s='(2+3)', output=5","Google, Amazon",Hard,"String, Stack",Use a stack to handle parentheses and signs.
168,Implement Stack using Queues,"Implement a stack using one or two queues, supporting push, pop, top, and empty operations. Simulate stack behavior in O(n) time for push (with one queue) or O(1) for most operations with two queues.","ops=['MyStack','push','push','top','pop','empty'], args=[[],1,2,2,2,[]], output=[null,null,null,2,2,false]","ops=['MyStack','push','top'], args=[[],1,[]], output=[null,null,1]","ops=['MyStack','empty'], args=[[],[]], output=[null,true]","ops=['MyStack','push','pop'], args=[[],1,[]], output=[null,null,1]","ops=['MyStack','push','push','pop'], args=[[],1,2,[]], output=[null,null,null,2]","Google, Amazon",Easy,"Stack, Queue, Design",Use one or two queues to simulate stack operations.
169,Invert Binary Tree,"Invert a binary tree by swapping every node’s left and right children. Use recursive or iterative DFS for O(n) time, handling empty or single-child trees.","root=[4,2,7,1,3,6,9], output=[4,7,2,9,6,3,1]","root=[2,1,3], output=[2,3,1]","root=[1], output=[1]","root=[1,2], output=[1,null,2]","root=[1,null,2], output=[1,2,null]","Google, Amazon",Easy,"Tree, DFS",Swap left and right children recursively.
170,Basic Calculator II,"Evaluate a string expression with addition, subtraction, multiplication, and division, respecting operator precedence. Use a stack or two-pass parsing for O(n) time, handling spaces and single numbers.","s='3+2*2', output=7","s=' 3/2 ', output=1","s=' 3+5 / 2 ', output=5","s='1+2*3', output=7","s='14-3/2', output=13","Google, Amazon",Medium,"String, Stack","Evaluate multiplication/division first, then addition/subtraction."
171,Summary Ranges,"Summarize consecutive ranges in a sorted integer array with no duplicates. Iterate through the array to group ranges in O(n) time, formatting as 'a->b' for ranges or 'a' for single numbers.","nums=[0,1,2,4,5,7], output=['0->2','4->5','7']","nums=[0,2,3,4,6,8,9], output=['0','2->4','6','8->9']","nums=[], output=[]","nums=[1], output=['1']","nums=[1,3], output=['1','3']","Google, Amazon",Easy,Array,Iterate and group consecutive numbers into ranges.
172,Majority Element II,"Find all elements in an array that appear more than n/3 times. Use Boyer-Moore voting for O(n) time and O(1) space, handling cases with zero, one, or two majority elements.","nums=[3,2,3], output=[3]","nums=[1], output=[1]","nums=[1,2], output=[]","nums=[2,2,2,1,1], output=[2]","nums=[1,1,1,3,3,2,2,2], output=[1,2]","Google, Amazon",Medium,"Array, Boyer-Moore Voting",Extend Boyer-Moore voting for elements > n/3.
173,Kth Smallest Element in a BST,"Find the kth smallest element in a binary search tree. Use inorder traversal with a stack for O(h+k) time, where h is tree height, handling small k or single-node trees.","root=[3,1,4,null,2], k=1, output=1","root=[5,3,6,2,4,null,null,1], k=3, output=3","root=[1], k=1, output=1","root=[3,1,4], k=2, output=3","root=[5,3,7], k=2, output=3","Google, Amazon",Medium,"Tree, DFS",Use inorder traversal to find kth smallest.
174,Power of Two,"Determine if a number is a power of two. Check if only one bit is set using bitwise operations in O(1) time, handling zero and negative numbers.","n=1, output=true","n=16, output=true","n=3, output=false","n=0, output=false","n=4, output=true","Google, Amazon",Easy,"Math, Bit Manipulation",Check if only one bit is set.
175,Implement Queue using Stacks,"Implement a queue using two stacks, supporting push, pop, peek, and empty operations. Use one stack for enqueue and another for dequeue in O(1) amortized time for pop/peek.","ops=['MyQueue','push','push','peek','pop','empty'], args=[[],1,2,1,1,[]], output=[null,null,null,1,1,false]","ops=['MyQueue','push','peek'], args=[[],1,[]], output=[null,null,1]","ops=['MyQueue','empty'], args=[[],[]], output=[null,true]","ops=['MyQueue','push','pop'], args=[[],1,[]], output=[null,null,1]","ops=['MyQueue','push','push','pop'], args=[[],1,2,[]], output=[null,null,null,1]","Google, Amazon",Easy,"Stack, Queue, Design",Use two stacks to simulate queue operations.
176,Palindrome Linked List,"Check if a linked list is a palindrome. Find the middle, reverse the second half, and compare in O(n) time and O(1) space, handling odd or even-length lists.","head=[1,2,2,1], output=true","head=[1,2], output=false","head=[1], output=true","head=[1,1], output=true","head=[1,2,3,2,1], output=true","Google, Amazon",Easy,Linked List,Reverse second half and compare.
177,Lowest Common Ancestor of a Binary Search Tree,"Find the lowest common ancestor of two nodes in a binary search tree. Use BST properties to traverse to the LCA in O(h) time, where h is tree height, handling cases where nodes are equal.","root=[6,2,8,0,4,7,9,null,null,3,5], p=2, q=8, output=6","root=[6,2,8], p=2, q=8, output=6","root=[2,1], p=2, q=1, output=2","root=[2,1,3], p=1, q=3, output=2","root=[6,2,8,0,4], p=2, q=4, output=2","Google, Amazon",Easy,"Tree, DFS",Use BST properties to find LCA.
178,Lowest Common Ancestor of a Binary Tree,"Find the lowest common ancestor of two nodes in a binary tree. Use DFS to find paths to both nodes and identify the LCA in O(n) time, handling cases where one node is the LCA.","root=[3,5,1,6,2,0,8,null,null,7,4], p=5, q=1, output=3","root=[3,5,1], p=5, q=1, output=3","root=[1,2], p=1, q=2, output=1","root=[1,2,3], p=2, q=3, output=1","root=[3,5,1,6,2], p=5, q=2, output=3","Google, Amazon",Medium,"Tree, DFS","Find paths to p and q, then find common ancestor."
179,Delete Node in a Linked List,"Delete a given node in a linked list (not the tail) by copying the next node’s value and deleting it. Adjust pointers in O(1) time, assuming the node is valid and not the last.","node=4->5->1->9, node=5, output=4->1->9","node=4->5->1->9, node=1, output=4->5->9","node=1->2, node=1, output=2","node=1->2->3, node=2, output=1->3","node=1->2->3->4, node=3, output=1->2->4","Google, Amazon",Easy,Linked List,Copy next node’s value and delete next node.
180,Product of Array Except Self,"Compute an array where each element is the product of all other elements, without using division. Use left and right product passes for O(n) time and O(1) output space, handling zeros.","nums=[1,2,3,4], output=[24,12,8,6]","nums=[-1,1], output=[1,-1]","nums=[1,2], output=[2,1]","nums=[0,1], output=[1,0]","nums=[2,3,4], output=[12,8,6]","Google, Amazon",Medium,Array,Compute products of left and right parts.
181,Sliding Window Maximum,"Find the maximum element in each sliding window of size k in an array. Use a deque to track indices of potential maximums in O(n) time, handling single-element windows.","nums=[1,3,-1,-3,5,3,6,7], k=3, output=[3,3,5,5,6,7]","nums=[1], k=1, output=[1]","nums=[1,2], k=2, output=[2]","nums=[7,2,4], k=2, output=[7,4]","nums=[1,2,3], k=3, output=[3]","Google, Amazon",Hard,"Array, Sliding Window, Deque",Use a deque to track maximums in the window.
182,Search a 2D Matrix II,"Search for a target in an m x n matrix where each row and column is sorted. Start from the top-right corner for O(m+n) time, eliminating rows or columns based on comparisons.","matrix=[[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target=5, output=true","matrix=[[1,4,7],[2,5,8],[3,6,9]], target=20, output=false","matrix=[[1]], target=1, output=true","matrix=[[1,2]], target=2, output=true","matrix=[[1],[2]], target=2, output=true","Google, Amazon",Medium,"Array, Binary Search",Search from top-right corner to leverage sorted properties.
183,Different Ways to Add Parentheses,"Compute all possible results of an expression by adding parentheses around operators. Use divide-and-conquer to split at operators for O(2^n) time, handling single numbers or simple expressions.","expression='2-1-1', output=[0,2]","expression='2*3-4*5', output=[-34,-14,-10,-10,10]","expression='1', output=[1]","expression='2+3', output=[5]","expression='2*3', output=[6]","Google, Amazon",Medium,Divide and Conquer,Recursively split expression at operators.
184,Valid Anagram,"Check if two strings are anagrams by having identical character frequencies. Use a hash map or sorting for O(n) or O(n log n) time, handling empty or single-character strings.","s='anagram', t='nagaram', output=true","s='rat', t='car', output=false","s='a', t='a', output=true","s='ab', t='ba', output=true","s='aacc', t='ccac', output=false","Google, Amazon",Easy,"String, Hash Table",Compare character frequencies using hash map or sorting.
185,Shortest Word Distance,"Find the minimum distance between two words in an array of strings. Track indices of both words and compute the minimum difference in O(n) time, handling cases where words are adjacent.","words=['practice','makes','perfect','coding','makes'], word1='coding', word2='practice', output=3","words=['practice','makes','perfect','coding','makes'], word1='makes', word2='coding', output=1","words=['a','b'], word1='a', word2='b', output=1","words=['a','a','b'], word1='a', word2='b', output=1","words=['a','b','c'], word1='a', word2='c', output=2","Google, Amazon",Easy,Array,Track indices of words and find minimum distance.
186,Shortest Word Distance II,"Design a data structure to find the shortest distance between two words in an array efficiently. Store word indices in a hash map for O(n) preprocessing and O(min(m,n)) query time, where m,n are word occurrences.","ops=['WordDistance','shortest','shortest'], args=[['practice','makes','perfect','coding','makes'],['coding','practice'],['makes','coding']], output=[null,3,1]","ops=['WordDistance','shortest'], args=[['a','b'],['a','b']], output=[null,1]","ops=['WordDistance','shortest'], args=[['a','a','b'],['a','b']], output=[null,1]","ops=['WordDistance','shortest'], args=[['a','b','c'],['a','c']], output=[null,2]","ops=['WordDistance','shortest'], args=[['coding','coding','coding'],['coding','coding']], output=[null,1]","Google, Amazon",Medium,"Hash Table, Design",Store word indices in a hash map for efficient distance queries.
187,Shortest Word Distance III,"Find the minimum distance between two words in an array, allowing the same word for both inputs. Handle the case where word1 equals word2 by tracking consecutive occurrences in O(n) time.","words=['practice','makes','perfect','coding','makes'], word1='makes', word2='makes', output=1","words=['practice','makes','perfect','coding','makes'], word1='coding', word2='practice', output=3","words=['a','a'], word1='a', word2='a', output=1","words=['a','b'], word1='a', word2='b', output=1","words=['a','a','b'], word1='a', word2='b', output=1","Google, Amazon",Medium,Array,Handle case where word1 equals word2 in distance calculation.
188,Strobogrammatic Number,"Check if a number string is strobogrammatic, meaning it looks the same when rotated 180 degrees (e.g., 69, 88). Use two pointers to verify valid digit pairs (0, 1, 6, 8, 9) in O(n) time, handling single digits.","num='69', output=true","num='88', output=true","num='962', output=false","num='1', output=true","num='25', output=false","Google, Amazon",Easy,"String, Two Pointers",Check if number is valid when rotated 180 degrees.
